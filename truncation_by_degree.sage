load("~/ma611-code/solid_angle.sage")
load("~/ma611-code/decomp.sage")

# In the following, we investigate the error of the M-th order
# truncation of Ribando's solid angle measure hypergeometric
# series formula. We consider simplicial cones, having positive
# definite associated matrices in dimensions two, three, and
# four, whose exact solid angle measures is known. We determine
# the degree (M) at which the truncated series is within a given
# `delta` of the exact measure.

# **********************************************************
#         Degree truncation for 2d simplicial cones
# **********************************************************


def truncation_deg_list_2d(A, t=6):
    r"""
    Return a list of pair giving the allowable error (delta), and
    the truncation degree needed to be within the allowable error.

    INPUT:

    - ``A`` -- 2x2 matrix whose row vectors generate a two-dimensional
    simplicial cone.

    - ``t`` -- (integer) corresponding to the smallest allowable error for
    which we want the truncation degree. That is, we look at truncation
    degrees for delta = 1e-1, 1e-2, ..., 1e-t.

    OUTPUT:

    - A list of pairs of the form [delta, truncation degree]

    EXAMPLES:

    In the following example, we consider the cone corresponding to the
    matrix P. The list tells us the degree we have to truncate at to be
    within delta of the exact value. For instance, to be within 1e-2 of
    the exact solid angle measure of the cone, we have to truncate Ribando's
    hypergeometric series at degree at least 42::

        sage: P = matrix([[-1,3],[4,-5]])
        sage: truncation_deg_list_2d(P, t=6)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 12],
        [1.00000000000000e-2, 42],
        [1.00000000000000e-3, 75],
        [1.00000000000000e-4, 108],
        [1.00000000000000e-5, 142],
        [1.00000000000000e-6, 177]]

        sage: logging.disable(logging.INFO)
        sage: abs(solid_angle_2d(P)-solid_angle_general(P, deg=42)) < 1e-2
        True
        sage: abs(solid_angle_2d(P)-solid_angle_general(P, deg=41)) < 1e-2
        False

    The following is another example showcasing the truncation degrees
    for a simplicial two-dimensional cone::

        sage: R = matrix([[4,9],[-1,2]])
        sage: truncation_deg_list_2d(R, 8) # optional
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 0],
        [1.00000000000000e-2, 3],
        [1.00000000000000e-3, 7],
        [1.00000000000000e-4, 12],
        [1.00000000000000e-5, 17],
        [1.00000000000000e-6, 21],
        [1.00000000000000e-7, 26],
        [1.00000000000000e-8, 31]]


    This example illustrates how one can use the function to determine
    the truncation degree for a specific delta. In particular, it tells us
    that to be within 1e-6 of the normalized solid angle measure of the cone
    generated by the vectors [1,2] and [4,5], we need to truncate at a degree
    D > 315.::

        sage: H = matrix([[1,2],[4,5]])
        sage: truncation_deg_list_2d(H, 6)[6]
        [1.00000000000000e-6, 315]

    In the following, we consider the truncation degrees corresponding to an
    error within 1e-4 for various cones::

        sage: A = matrix([[1,0],[-1,8]])
        sage: truncation_deg_list_2d(A, 4)[4]
        [1.00000000000000e-4, 3]

        sage: A = matrix([[1,9],[-1,8]])
        sage: truncation_deg_list_2d(A, 4)[4] # optional
        [1.00000000000000e-4, 111]

        sage: A = matrix([[3,7],[8,9]])
        sage: truncation_deg_list_2d(A, 4)[4] # optional
        [1.00000000000000e-4, 69]

    .. NOTE::

        The exact normalized solid angle measures for two-dimensional simpli-
        cial cones can be determined using the solid_angle_2d function.

        Using this function, one obtains lists of (delta, truncation deg)
        pairs. The relation between truncation deg and log(delta) is linear.
    """
    RR.scientific_notation(True)
    deg = 1000000000000
    list_deg_n = []
    for i in range(t+1):
        delta = RR(10 ** -i)
        d = A.nrows()
        v = matrix(RDF, [A[i]/A[i].norm() for i in range(d)])
        da = int(d * (d-1) / 2)
        const = sqrt((v * v.transpose()).determinant()) / (RDF(4*pi) ** (d/2))
        alpha = [0] * da
        for i in range(d - 1):
            for j in range(i + 1, d):
                k = (2*d - i - 1) * i/2 + j - i - 1
                alpha[k] = v[i] * v[j]
        partial_sum = 0
        for n in range(deg + 1):
            sum_deg_n = 0
            for a in composition_of_n_into_k_parts(n, da):
                alphatoa = 1
                for k in range(da):
                    alphatoa = alpha[k] ** a[k] * alphatoa
                    if alphatoa == 0:
                        break
                if alphatoa == 0:
                    continue
                t = (-2) ** (sum(a))
                fact_denom = prod([factorial(a[k]) for k in range(da)])
                coef = t / fact_denom
                for i in range(d):
                    s_i = 0
                    for j in range(d):
                        if j != i:
                            m_1 = max(i, j)
                            m_0 = min(i, j)
                            k = (2*d - m_0 - 1) * m_0 / 2 + m_1 - m_0 - 1
                            s_i += a[k]
                    coef = coef * gamma(0.5 * (s_i + 1))
                sum_deg_n += (coef * alphatoa)
            partial_sum += sum_deg_n
            if abs((const * partial_sum) - solid_angle_2d(A)) < delta:
                list_deg_n.append([delta, n])
                break
    return list_deg_n

# **********************************************************
#         Degree truncation for 3d simplicial cones
# **********************************************************


def truncation_deg_list(A, t=6):
    r"""
    Return a list of tuples giving the allowable error (delta), and
    the truncation degree corresponding to delta.

    INPUT:

    - ``A`` -- 3x3 matrix whose row vectors generate a three-dimensional
    simplicial cone.

    - ``t`` -- (integer) corresponding to the smallest allowable error for
    which we want the truncation degree. That is, we look at truncation
    degrees for delta = 1e-1, 1e-2, ..., 1e-t.

    OUTPUT:

    - A list of pairs of the form [delta, truncation degree]

    EXAMPLES:

    In the following example, we consider the cone corresponding to the matrix
    B. The list tells us the degree we have to truncate at to be within delta
    of the exact value. For instance, to be within 1e-4 of the exact solid
    angle measure of the cone, we have to truncate Ribando's hypergeometric
    series at degree at least 99::

        sage: B = matrix([[0,1,-2],[1,0,17],[39/34, -1, -1/2]])
        sage: truncation_deg_list(B, t=5) # long time (3.95 s)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 10],
        [1.00000000000000e-2, 38],
        [1.00000000000000e-3, 68],
        [1.00000000000000e-4, 99],
        [1.00000000000000e-5, 130]]

        sage: solid_angle_general(B, deg=99)-solid_angle_3d(B) < 1e-4
        True

    This example shows the truncation degrees for the two cones in the
    decomposition of the cone corresponding to C1::

        sage: C1 = matrix([[1,-1,0],[2,1,1],[-1,0,0]])
        sage: C = list(generate_cones_decomposition(C1))
        sage: truncation_deg_list(C[0][0], t=7) # never tested (194 s)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 0],
        [1.00000000000000e-2, 0],
        [1.00000000000000e-3, 56],
        [1.00000000000000e-4, 179],
        [1.00000000000000e-5, 322],
        [1.00000000000000e-6, 471],
        [1.00000000000000e-7, 625]]

        sage: truncation_deg_list(C[1][0], t=7) # long time (6.47 s)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 8],
        [1.00000000000000e-2, 29],
        [1.00000000000000e-3, 52],
        [1.00000000000000e-4, 75],
        [1.00000000000000e-5, 99],
        [1.00000000000000e-6, 123],
        [1.00000000000000e-7, 148]]

    Here we consider truncation degrees of another set of cones in a
    decomposition of a three-dimensional cone::

        sage: Z_1 = matrix([[-1,-1,-1],[2,2,1],[2,1,1]])
        sage: Z = list(generate_cones_decomposition(Z_1))
        sage: truncation_deg_list(Z[0][0]) # never tested (132 s)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 4],
        [1.00000000000000e-2, 42],
        [1.00000000000000e-3, 91],
        [1.00000000000000e-4, 143],
        [1.00000000000000e-5, 197],
        [1.00000000000000e-6, 252]]

        sage: truncation_deg_list(Z[1][0]) # long time (50 s)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 23],
        [1.00000000000000e-2, 82],
        [1.00000000000000e-3, 145],
        [1.00000000000000e-4, 210],
        [1.00000000000000e-5, 277],
        [1.00000000000000e-6, 344]]


    This example illustrates how one can use the function to determine
    the truncation degree for a specific delta::

        sage: A=matrix([[1,0,1],[-1,0,0],[0,1,2]])
        sage: truncation_deg_list(A, t=3)[3]
        [1.00000000000000e-3, 6]

    Here, we consider the truncation degree so that the truncation is
    within 1e-6 of the actual measure.::

        sage: A = matrix([[13,4,-10],[1,-12,0],[0,-4,-2]])
        sage: truncation_deg_list(A, t=6)[6] # long time (7.16 s)
        [1.00000000000000e-6, 62]

    In the following, we consider truncation degrees for various margins of
    error ranging from 1e-8 to 1e-1::

        sage: D = matrix([[4,-1,1],[0,0,4],[6,1,0]])
        sage: truncation_deg_list(D, t=8) # long time (7.47 s)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 0],
        [1.00000000000000e-2, 4],
        [1.00000000000000e-3, 24],
        [1.00000000000000e-4, 49],
        [1.00000000000000e-5, 75],
        [1.00000000000000e-6, 101],
        [1.00000000000000e-7, 128],
        [1.00000000000000e-8, 155]]

    In the following, we consider the truncation degrees corresponding to an
    error within 1e-4 for various cones::

        sage: X = matrix([[-1,-2,1],[1,0,2],[0,2,0]])
        sage: truncation_deg_list(X, t=4)[4]
        [1.00000000000000e-4, 27]

        sage: F = matrix([[6,1,0],[0,1,-2],[1,1,1]])
        sage: truncation_deg_list(F, t=4)[4]
        [1.00000000000000e-4, 10]

        sage: N = matrix([[0,1,-1],[2,1,1],[-1,-2,-1]])
        sage: truncation_deg_list(N, t=4)[4]
        [1.00000000000000e-4, 55]

    We consider another set of cones in a decomposition. Notice that to be
    within 1e-3 of the exact measure, the first cone has truncation degree 49
    while the second has truncation degree 16::

        sage: E_1 = matrix([[1,0,0],[1,7,0],[-1,-1,-1]])
        sage: E = list(generate_cones_decomposition(E_1))
        sage: truncation_deg_list(E[0][0], t=3)[3]
        [1.00000000000000e-3, 49]

        sage: truncation_deg_list(E[1][0], t=3)[3]
        [1.00000000000000e-3, 16]

    .. NOTE::

        The exact normalized solid angle measures for three-dimensional simpli-
        cial cones can be determined using the solid_angle_3d function.

        Using this function, one obtains lists of (delta, truncation deg)
        pairs. The relation between truncation deg and log(delta) is linear.
    """
    RR.scientific_notation(True)
    deg = 1000000000000
    list_deg_n = []
    for i in range(t+1):
        delta = RR(10**-i)
        d = A.nrows()
        v = matrix(RDF, [A[i]/A[i].norm() for i in range(d)])
        da = int(d * (d-1) / 2)
        const = sqrt((v * v.transpose()).determinant()) / (RDF(4*pi) ** (d/2))
        alpha = [0] * da
        for i in range(d - 1):
            for j in range(i + 1, d):
                k = (2*d - i - 1) * i/2 + j - i - 1
                alpha[k] = v[i] * v[j]
        partial_sum = 0
        for n in range(deg + 1):
            sum_deg_n = 0
            for a in composition_of_n_into_k_parts(n, da):
                alphatoa = 1
                for k in range(da):
                    alphatoa = alpha[k] ** a[k] * alphatoa
                    if alphatoa == 0:
                        break
                if alphatoa == 0:
                    continue
                t = (-2) ** (sum(a))
                fact_denom = prod([factorial(a[k]) for k in range(da)])
                coef = t / fact_denom
                for i in range(d):
                    s_i = 0
                    for j in range(d):
                        if j != i:
                            m_1 = max(i, j)
                            m_0 = min(i, j)
                            k = (2*d - m_0 - 1) * m_0 / 2 + m_1 - m_0 - 1
                            s_i += a[k]
                    coef = coef * gamma(0.5 * (s_i + 1))
                sum_deg_n += (coef * alphatoa)
            partial_sum += sum_deg_n
            if abs((const * partial_sum) - solid_angle_3d(A)) < delta:
                list_deg_n.append([delta, n])
                break
    return list_deg_n


# **********************************************************
#         Degree truncation for 4d simplicial cone: I1
#
# To date, the only 4d cone with known exact solid angle
# measure, not requiring decomposition, that we know of is
# I1 (appearing in Hajja and Walker (2002)). This cone is
# simplicial with positive definite associated matrix. Using
# a similar method, as above, we determine the following trunc-
# ation degree list for I1:
#
#    [(1e-1, 5), (1e-2, 18), (1e-3, 33), (1e-4, 48),
#        (1e-5, 63), (1e-6, 78), (1e-7, 93)]
#
# **********************************************************

# **********************************************************
#         Useful Functions
# **********************************************************

def line_of_best_fit_deg_delta(A, t=6, color="pink", plot_relation=False):
    r"""
    Determines the line of best fit for the relation of log(delta)
    where delta is the allowable error, and the truncation degree.

    INPUT:

    - ``A`` -- matrix; 3x3 matrix corresponding to the simplicial
                three-dimensional cone of interest
    - ``t`` - integer; corresponds to the allowable error, which
                will range from `1e-0` to `1e-t`.
    -``plot_relation`` - (optional) True or False; when set to True,
                         the function outputs a plot of the relation
                         in semilogx scale.

    OUTPUT:

    - `m` is the slope of the line of best fit
    - `b` is the y-intercept of the line of best fit
    - plot of the relation (log(delta), truncation degree)

    EXAMPLES:

    In the following example, we see that to be within 1e-3 of the
    exact measure, one needs to truncate Ribando's series at a
    multiexponent with 1-norm 8 or greater. Similarly, a margin of
    error of 1e-4 requires a multiexponent with 1-norm at least 20,
    while a margin of error of 1e-5 requires a multiexponent with
    1-norm at least 33. The relation between x=log(margin of error)
    and the required 1-norm ``y`` is given by the line ``y=mx+b``::

        sage: A=matrix([[1,0,1],[0,-1,2],[3,1,0]])
        sage: line_of_best_fit_deg_delta(A, t=5)
        [-3.00000000000000e0, 8]
        [-4.00000000000000e0, 20]
        [-5.00000000000000e0, 33]
        [b == -29.66666665550475, m == -12.49999999732114]

    In the following example we see the relation for log(error) and
    the required truncation degree/multiexponent is best described
     by the line ``truncation degree =
     -17.035714285753624(-log(error))-13.000000000030546::

        sage: A = matrix([[0,1,-1],[2,1,1],[-1,-2,-1]])
        sage: line_of_best_fit_deg_delta(A, t=7) # long time (3.27 s)
        [-1.00000000000000e0, 5]
        [-2.00000000000000e0, 21]
        [-3.00000000000000e0, 37]
        [-4.00000000000000e0, 55]
        [-5.00000000000000e0, 72]
        [-6.00000000000000e0, 89]
        [-7.00000000000000e0, 107]
        [b == -13.000000000030546, m == -17.035714285753624]


    ..NOTE::

        Compare the slope of the line of best fit with`2/lambda` where
        lambda is the minimum eigenvalue of the associated matrix of A.
    """
    list = []
    T = truncation_deg_list(A, t=t)
    for i in range(t+1):
        if T[i][1] == 0:
            continue
        else:
            list_ij = [log(T[i][0], 10), T[i][1]]
            print(list_ij)
            list.append(list_ij)
    var('m,b')
    model(x) = m*x+b
    if plot_relation is True:
        print(find_fit(list, model))
        return list_plot(list, axes_labels=['log(error)', 'truncation-deg'],
                         color=color)
    else:
        print(find_fit(list, model))


def min_eigenval_assoc_matrix(A):
    r"""
    Return the minimum eigenvalue of the associated matrix of the cone
    corresponding to the matrix ``A``.

    INPUT:

    - ``A`` -- A matrix where the row vectors represent the extreme
    rays/vectors of the cone we wish to decompose.

    OUTPUT:

    - the minimum eigenvalue of the associated matrix of the cone
    corresponding to the matrix ``A``

    EXAMPLES:

    This example shows the minimum eigenvalue of the associated
    matrix of the cone corresponding to the matrix A::

        sage: A = matrix([[0,1,-1],[2,1,1],[-1,-2,-1]])
        sage: min_eigenval_assoc_matrix(A)
        0.11808289631180291

    In the following, we consider cones in the decomposition of the cone
    corresponding to ``A``. This decomposition yields cones with positive
    definite associated matrices. Thus, we expect the minimum eigenvalues
    of each of the associated matrices to be positive::

        sage: A=matrix([[1,1,0,1],[0,4,-2,5],[3,0,-1,2],[1,3,-7,4]])
        sage: T=list(generate_cones_decomposition(A))
        sage: min_eigenval_assoc_matrix(T[0][0])
        0.03370507513456844
        sage: min_eigenval_assoc_matrix(T[1][0])
        0.031309656606767655
        sage: min_eigenval_assoc_matrix(T[2][0])
        0.005909017246413873
        sage: min_eigenval_assoc_matrix(T[3][0])
        0.01373321678774353
        sage: min_eigenval_assoc_matrix(T[4][0])
        0.013644678064312021

    .. NOTE::

        The minimum eigenvalue of the associated matrix has shown to have
        interesting properties. When a cone's associated matrix is tridiag-
        onal, with off-diagonal entries corresponding to the multi-varibale
        `(b_1, ..., b_{n-1})`, one can show that the point
        `(b_1/(1-lambda), ..., b_{n-1}/(1-lambda))` lies on the boundary of
        the domain of convergence of Ribando's solid angle formula. Here,
        `lambda` is the minimum eigenvalue of the associated matrix.
    """
    d = A.nrows()
    M_exact = A * A.transpose()
    vnorm = [A[i].norm() for i in range(d)]
    M = matrix(RDF, d)
    for i in range(d):
        for j in range(d):
            if i != j:
                M_exact[i, j] = - abs(M_exact[i, j])
            M[i, j] = RDF(M_exact[i, j] / (vnorm[i] * vnorm[j]))
    return min(M.eigenvalues())


def onlydeg(A, deg1=0, deg2=100, tridiag=None):
    r"""
    Return the sum of all the terms in Ribando's solid angle measure hypergeo-
    metric series, where the 1-norm of the multiexponent is at least ``deg1``
    and at most ``deg2.

    INPUT:

    - ``A`` -- a matrix or a list that is convertible to a matrix; the row
      vectors of ``A`` span the full-dimensional simplicial cone for which
      we compute its solid angle. The cone corresponding to ``A`` should
      not require any decomposition; that is, it should be simplicial and
      have a positive definite associated matrix.

    - ``deg1`` -- integer (default: `0`); ``deg1`` is the minimum sum of the
      powers of the `\alpha_{ij}`'s in the summation (i.e. it is the minimum
      sum of the terms in the multiexponent.)

    - ``deg2`` -- integer (default: `100`); ``deg2`` is the maximum sum of the
      powers of the `\alpha_{ij}`'s in the summation (i.e. it is the maximum
      sum of the terms in the multiexponent.)

    - ``tridiag`` -- either "False" (by default) or "True". One can set this
    parameter to True when the associated matrix is known to be tridiagonal.

    OUTPUT:

    - sum of the terms in Ribando's solid angle measure series ranging from
    ``deg1`` to ``deg2``.

    EXAMPLES:

    This example shows the partial sum of the series. The output is the sum
    over all the multiexponents in ``\mathbb{N}^3``, where the sum of the
    components is at most 5. The function gives information in the form of a
    list of tuples of the form ``[k=1-norm of multiexponent, sum of the terms
    whose multiexponent has 1-norm k, partial sum]::

        sage: A=[[1,0,0],[1,2,1],[-1,0,1]]
        sage: onlydeg(A, deg2=5)
        INFO: [0, 0.07216878364870323, 0.07216878364870323]
        INFO: [1, 0.013730776798130125, 0.08589956044683336]
        INFO: [2, 0.010793349291909797, 0.09669290973874316]
        INFO: [3, 0.0047813228524050955, 0.10147423259114825]
        INFO: [4, 0.0031861893252341277, 0.10466042191638236]
        INFO: [5, 0.0017926947292750094, 0.10645311664565738]
        0.10645311664565738


    In the following, we show the function can be used to determine the sum
    of various terms in the series, and that ``deg1`` need not be 0::

        sage: logging.disable(logging.INFO)
        sage: A=matrix([[0,-1,2,1],[1,0,1,-1],[-2,1,0,1],[6,-6,-4,2]])
        sage: onlydeg(A, deg2=10)
        0.027701362535208923

        sage: onlydeg(A, deg1=0, deg2=7)
        0.023190579905755907

        sage: onlydeg(A, deg1=8, deg2=10)
        0.004510782629453016

    .. NOTE::

       This function is useful if one wishes to see the terms corresponding
       to a fixed degree, i.e., the sum of the terms whose multiexponents
       have the same 1-norm. For computing solid angle measures of cones that
       are not simplicial, or require decomposition, one should see the
       `solid_angle_general` and `solid_angle_measure` functions.
    """
    if not hasattr(A, 'nrows'):
        A = matrix(A)
    if A.rank() < A.ncols():
        logging.warning("cone not full-dimensional")
        return 0
    d = A.nrows()
    v = matrix(RDF, [A[i]/A[i].norm() for i in range(d)])
    da = int(d * (d-1) / 2)
    const = sqrt((v * v.transpose()).determinant()) / (RDF(4*pi) ** (d/2))
    if tridiag is True:
        beta = [A[i] * A[i+1] / (A[i].norm()*A[i+1].norm()) for i
                in range(d-1)]
        partial_sum = 0
        for n in range(deg1, deg2+1):
            sum_deg_n = 0
            for b in composition_of_n_into_k_parts(n, d-1):
                betatob = prod([beta[k]**b[k] for k in range(d-1)])
                coef = (-2)**(sum(b)) / prod([factorial(b[k]) for k
                                              in range(d-1)])
                coef *= gamma(0.5*(b[0]+1))
                for i in range(d-2):
                    coef *= gamma(0.5*(b[i]+b[i+1]+1))
                coef *= gamma(0.5*(b[d-2]+1))
                sum_deg_n += coef * betatob
            partial_sum += sum_deg_n
            print(n, RDF(sum_deg_n), RDF(const*partial_sum))
        return RDF(const*partial_sum)
    alpha = [0] * da
    for i in range(d - 1):
        for j in range(i + 1, d):
            k = (2*d - i - 1) * i/2 + j - i - 1
            alpha[k] = v[i] * v[j]
    partial_sum = 0
    for n in range(deg1, deg2+1):
        sum_deg_n = 0
        for a in composition_of_n_into_k_parts(n, da):
            alphatoa = 1
            for k in range(da):
                alphatoa = alpha[k] ** a[k] * alphatoa
                if alphatoa == 0:
                    break
            if alphatoa == 0:
                continue
            t = (-2) ** (sum(a))
            fact_denom = prod([factorial(a[k]) for k in range(da)])
            coef = t / fact_denom
            for i in range(d):
                s_i = 0
                for j in range(d):
                    if j != i:
                        m_1 = max(i, j)
                        m_0 = min(i, j)
                        k = (2*d - m_0 - 1) * m_0 / 2 + m_1 - m_0 - 1
                        s_i += a[k]
                coef = coef * gamma(0.5 * (s_i + 1))
            sum_deg_n += coef * alphatoa
        partial_sum += sum_deg_n
        a_n = [n, const * sum_deg_n, const*partial_sum]
        logging.info(a_n)
    return(const*partial_sum)
