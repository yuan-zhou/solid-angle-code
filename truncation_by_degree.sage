load("solid_angle.sage")
load("decomp.sage")

# In the following, we investigate the error of the M-th order
# truncation of Ribando's solid angle measure hypergeometric
# series formula. We consider simplicial cones, having positive
# definite associated matrices in dimensions two, three, and
# four, whose exact solid angle measures is known. We determine
# the degree (M) at which the truncated series is within a given
# `delta` of the exact measure.

# **********************************************************
#         Degree truncation for 2d simplicial cones
# **********************************************************


def truncation_deg_list_2d(A, t=6):
    r"""
    Return a list of pair giving the allowable error (delta), and
    the truncation degree needed to be within the allowable error.

    INPUT:

    - ``A`` -- 2x2 matrix whose row vectors generate a two-dimensional
    simplicial cone.

    - ``t`` -- (integer) corresponding to the smallest allowable error for
    which we want the truncation degree. That is, we look at truncation
    degrees for delta = 1e-1, 1e-2, ..., 1e-t.

    OUTPUT:

    - A list of pairs of the form [delta, truncation degree]

    EXAMPLES:

    In the following example, we consider the cone corresponding to the
    matrix P. The list tells us the degree we have to truncate at to be
    within delta of the exact value. For instance, to be within 1e-2 of
    the exact solid angle measure of the cone, we have to truncate Ribando's
    hypergeometric series at degree at least 42::

        sage: P = matrix([[-1,3],[4,-5]])
        sage: truncation_deg_list_2d(P, t=6)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 12],
        [1.00000000000000e-2, 42],
        [1.00000000000000e-3, 75],
        [1.00000000000000e-4, 108],
        [1.00000000000000e-5, 142],
        [1.00000000000000e-6, 177]]

        sage: logging.disable(logging.INFO)
        sage: abs(solid_angle_2d(P)-solid_angle_general(P, deg=42)) < 1e-2
        True
        sage: abs(solid_angle_2d(P)-solid_angle_general(P, deg=41)) < 1e-2
        False

    The following is another example showcasing the truncation degrees
    for a simplicial two-dimensional cone::

        sage: R = matrix([[4,9],[-1,2]])
        sage: truncation_deg_list_2d(R, 8)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 0],
        [1.00000000000000e-2, 3],
        [1.00000000000000e-3, 7],
        [1.00000000000000e-4, 12],
        [1.00000000000000e-5, 17],
        [1.00000000000000e-6, 21],
        [1.00000000000000e-7, 26],
        [1.00000000000000e-8, 31]]


    This example illustrates how one can use the function to determine
    the truncation degree for a specific delta. In particular, it tells us
    that to be within 1e-6 of the normalized solid angle measure of the cone
    generated by the vectors [1,2] and [4,5], we need to truncate at a degree
    D > 315.::

        sage: H = matrix([[1,2],[4,5]])
        sage: truncation_deg_list_2d(H, 6)[6]
        [1.00000000000000e-6, 315]

    In the following, we consider the truncation degrees corresponding to an
    error within 1e-4 for various cones::

        sage: A = matrix([[1,0],[-1,8]])
        sage: truncation_deg_list_2d(A, 4)[4]
        [1.00000000000000e-4, 3]

        sage: A = matrix([[1,9],[-1,8]])
        sage: truncation_deg_list_2d(A, 4)[4]
        [1.00000000000000e-4, 111]

        sage: A = matrix([[3,7],[8,9]])
        sage: truncation_deg_list_2d(A, 4)[4]
        [1.00000000000000e-4, 69]

    .. NOTE::

        The exact normalized solid angle measures for two-dimensional simpli-
        cial cones can be determined using the solid_angle_2d function.

        Using this function, one obtains lists of (delta, truncation deg)
        pairs. The relation between truncation deg and log(delta) is linear.
    """
    RR.scientific_notation(True)
    deg = 1000000000000
    list_deg_n = []
    for i in range(t+1):
        delta = RR(10 ** -i)
        d = A.nrows()
        v = matrix(RDF, [A[i]/A[i].norm() for i in range(d)])
        da = int(d * (d-1) / 2)
        const = sqrt((v * v.transpose()).determinant()) / (RDF(4*pi) ** (d/2))
        alpha = [0] * da
        for i in range(d - 1):
            for j in range(i + 1, d):
                k = (2*d - i - 1) * i/2 + j - i - 1
                alpha[k] = v[i] * v[j]
        partial_sum = 0
        for n in range(deg + 1):
            sum_deg_n = 0
            for a in composition_of_n_into_k_parts(n, da):
                alphatoa = 1
                for k in range(da):
                    alphatoa = alpha[k] ** a[k] * alphatoa
                    if alphatoa == 0:
                        break
                if alphatoa == 0:
                    continue
                t = (-2) ** (sum(a))
                fact_denom = prod([factorial(a[k]) for k in range(da)])
                coef = t / fact_denom
                for i in range(d):
                    s_i = 0
                    for j in range(d):
                        if j != i:
                            m_1 = max(i, j)
                            m_0 = min(i, j)
                            k = (2*d - m_0 - 1) * m_0 / 2 + m_1 - m_0 - 1
                            s_i += a[k]
                    coef = coef * gamma(0.5 * (s_i + 1))
                sum_deg_n += (coef * alphatoa)
            partial_sum += sum_deg_n
            if abs((const * partial_sum) - solid_angle_2d(A)) < delta:
                list_deg_n.append([delta, n])
                break
    return list_deg_n

# **********************************************************
#         Degree truncation for 3d simplicial cones
# **********************************************************


def truncation_deg_list(A, t=6):
    r"""
    Return a list of tuples giving the allowable error (delta), and
    the truncation degree corresponding to delta.

    INPUT:

    - ``A`` -- 3x3 matrix whose row vectors generate a three-dimensional
    simplicial cone.

    - ``t`` -- (integer) corresponding to the smallest allowable error for
    which we want the truncation degree. That is, we look at truncation
    degrees for delta = 1e-1, 1e-2, ..., 1e-t.

    OUTPUT:

    - A list of pairs of the form [delta, truncation degree]

    EXAMPLES:

    In the following example, we consider the cone corresponding to the matrix
    B. The list tells us the degree we have to truncate at to be within delta
    of the exact value. For instance, to be within 1e-4 of the exact solid
    angle measure of the cone, we have to truncate Ribando's hypergeometric
    series at degree at least 99::

        sage: B = matrix([[0,1,-2],[1,0,17],[39/34, -1, -1/2]])
        sage: truncation_deg_list(B, t=5)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 10],
        [1.00000000000000e-2, 38],
        [1.00000000000000e-3, 68],
        [1.00000000000000e-4, 99],
        [1.00000000000000e-5, 130]]

        sage: solid_angle_general(B, deg=99)-solid_angle_3d(B) < 1e-4
        True

    This example shows the truncation degrees for the two cones in the
    decomposition of the cone corresponding to C1::

        sage: C1 = matrix([[1,-1,0],[2,1,1],[-1,0,0]])
        sage: C = list(generate_cones_decomposition(C1))
        sage: truncation_deg_list(C[0][0], t=7)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 0],
        [1.00000000000000e-2, 0],
        [1.00000000000000e-3, 56],
        [1.00000000000000e-4, 179],
        [1.00000000000000e-5, 322],
        [1.00000000000000e-6, 471],
        [1.00000000000000e-7, 625]]

        sage: truncation_deg_list(C[1][0], t=7)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 8],
        [1.00000000000000e-2, 29],
        [1.00000000000000e-3, 52],
        [1.00000000000000e-4, 75],
        [1.00000000000000e-5, 99],
        [1.00000000000000e-6, 123],
        [1.00000000000000e-7, 148]]

    Here we consider truncation degrees of another set of cones in a
    decomposition of a three-dimensional cone::

        sage: Z_1 = matrix([[-1,-1,-1],[2,2,1],[2,1,1]])
        sage: Z = list(generate_cones_decomposition(Z_1))
        sage: truncation_deg_list(Z[0][0])
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 4],
        [1.00000000000000e-2, 42],
        [1.00000000000000e-3, 91],
        [1.00000000000000e-4, 143],
        [1.00000000000000e-5, 197],
        [1.00000000000000e-6, 252]]

        sage: truncation_deg_list(Z[1][0])
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 23],
        [1.00000000000000e-2, 82],
        [1.00000000000000e-3, 145],
        [1.00000000000000e-4, 210],
        [1.00000000000000e-5, 277],
        [1.00000000000000e-6, 344]]


    This example illustrates how one can use the function to determine
    the truncation degree for a specific delta. Here, we consider the
    truncation degree so that the truncation is within 1e-6 of the actual
    measure.::

        sage: A = matrix([[13,4,-10],[1,-12,0],[0,-4,-2]])
        sage: truncation_deg_list(A, t=6)[6]
        [1.00000000000000e-6, 62]

    In the following, we consider truncation degrees for various margins of
    error ranging from 1e-8 to 1e-1::

        sage: D = matrix([[4,-1,1],[0,0,4],[6,1,0]])
        sage: truncation_deg_list(D, t=8)
        [[1.00000000000000e0, 0],
        [1.00000000000000e-1, 0],
        [1.00000000000000e-2, 4],
        [1.00000000000000e-3, 24],
        [1.00000000000000e-4, 49],
        [1.00000000000000e-5, 75],
        [1.00000000000000e-6, 101],
        [1.00000000000000e-7, 128],
        [1.00000000000000e-8, 155]]

    In the following, we consider the truncation degrees corresponding to an
    error within 1e-4 for various cones::

        sage: X = matrix([[-1,-2,1],[1,0,2],[0,2,0]])
        sage: truncation_deg_list(X, t=4)[4]
        [1.00000000000000e-4, 27]

        sage: F = matrix([[6,1,0],[0,1,-2],[1,1,1]])
        sage: truncation_deg_list(F, t=4)[4]
        [1.00000000000000e-4, 10]

        sage: N = matrix([[0,1,-1],[2,1,1],[-1,-2,-1]])
        sage: truncation_deg_list(N, t=4)[4]
        [1.00000000000000e-4, 55]

    We consider another set of cones in a decomposition. Notice that to be
    within 1e-3 of the exact measure, the first cone has truncation degree 49
    while the second has truncation degree 16::

        sage: E_1 = matrix([[1,0,0],[1,7,0],[-1,-1,-1]])
        sage: E = list(generate_cones_decomposition(E_1))
        sage: truncation_deg_list(E[0][0], t=3)[3]
        [1.00000000000000e-3, 49]

        sage: truncation_deg_list(E[1][0], t=3)[3]
        [1.00000000000000e-3, 16]

    .. NOTE::

        The exact normalized solid angle measures for three-dimensional simpli-
        cial cones can be determined using the solid_angle_3d function.

        Using this function, one obtains lists of (delta, truncation deg)
        pairs. The relation between truncation deg and log(delta) is linear.
    """
    RR.scientific_notation(True)
    deg = 1000000000000
    list_deg_n = []
    for i in range(t+1):
        delta = RR(10**-i)
        d = A.nrows()
        v = matrix(RDF, [A[i]/A[i].norm() for i in range(d)])
        da = int(d * (d-1) / 2)
        const = sqrt((v * v.transpose()).determinant()) / (RDF(4*pi) ** (d/2))
        alpha = [0] * da
        for i in range(d - 1):
            for j in range(i + 1, d):
                k = (2*d - i - 1) * i/2 + j - i - 1
                alpha[k] = v[i] * v[j]
        partial_sum = 0
        for n in range(deg + 1):
            sum_deg_n = 0
            for a in composition_of_n_into_k_parts(n, da):
                alphatoa = 1
                for k in range(da):
                    alphatoa = alpha[k] ** a[k] * alphatoa
                    if alphatoa == 0:
                        break
                if alphatoa == 0:
                    continue
                t = (-2) ** (sum(a))
                fact_denom = prod([factorial(a[k]) for k in range(da)])
                coef = t / fact_denom
                for i in range(d):
                    s_i = 0
                    for j in range(d):
                        if j != i:
                            m_1 = max(i, j)
                            m_0 = min(i, j)
                            k = (2*d - m_0 - 1) * m_0 / 2 + m_1 - m_0 - 1
                            s_i += a[k]
                    coef = coef * gamma(0.5 * (s_i + 1))
                sum_deg_n += (coef * alphatoa)
            partial_sum += sum_deg_n
            if abs((const * partial_sum) - solid_angle_3d(A)) < delta:
                list_deg_n.append([delta, n])
                break
    return list_deg_n


# **********************************************************
#         Degree truncation for 4d simplicial cone: I1
#
# To date, the only 4d cone with known exact solid angle
# measure, not requiring decomposition, that we know of is
# I1 (appearing in Hajja and Walker (2002)). This cone is
# simplicial with positive definite associated matrix. Using
# a similar method, as above, we determine the following trunc-
# ation degree list for I1:
#
#    [(1e-1, 5), (1e-2, 18), (1e-3, 33), (1e-4, 48),
#        (1e-5, 63), (1e-6, 78), (1e-7, 93)]
#
# **********************************************************

# **********************************************************
#         Useful Functions
# **********************************************************

def line_of_best_fit_deg_delta(L, color="pink"):
    r"""
    Determines the line of best fit for the relation of log(delta)
    where delta is the allowable error, and the truncation degree.

    INPUT:

    - ``L`` -- list of pairs of the form (delta, truncation degree) which
    can be obtained via the truncation_deg_list functions above.


    OUTPUT:

    - `m` is the slope of the line of best fit
    - `b` is the y-intercept of the line of best fit
    - plot of the relation (log(delta), truncation degree) given in L
    """
    list = []
    for (i, j) in L:
        list_ij = [log(i, 10), j]
        print(list_ij)
        list.append(list_ij)
    var('m,b')
    model(x) = m*x+b
    print(find_fit(list, model))
    return list_plot(list, axes_labels=['$log(error)$', '$truncation-deg$'],
                     color=color)


def min_eigenval_assoc_matrix(A):
    r"""
    Gives the minimum eigenvalue of the associated matrix of A.
    """
    d = A.nrows()
    M_exact = A * A.transpose()
    vnorm = [A[i].norm() for i in range(d)]
    M = matrix(RDF, d)
    for i in range(d):
        for j in range(d):
            if i != j:
                M_exact[i, j] = - abs(M_exact[i, j])
            M[i, j] = RDF(M_exact[i, j] / (vnorm[i] * vnorm[j]))
    return min(M.eigenvalues())
