
def sol(u,v):
    """ Returns the solid angle between 2 rays from origin in R^2:
            Parameters:
                u=vector([a,b]) is one of the rays, emanating from origin extending through point (a,b)
                v=vector([c,d]) is one of the rays, emanating from origin extending through point (c,d)

            Returns: final_calc.numerical_approx() the angle between u and v, as a ratio, and in decimal form
       
    """
    p = u.dot_product(v)
    a=u.norm()
    b=v.norm()
    cs=p/(a*b)
    final_calc = arccos(cs) / (2*pi)
    return final_calc.numerical_approx()

def sol(A):
    """ Returns the solid angle between 2 rays from origin in R^2:
            Parameters:
                A = 2x2 matrix whose rows correspond to the two rays, u and v

            Returns: final_calc.numerical_approx() the angle between u and v, as a ratio, and in decimal form
       
    """
    u=A.row(0)
    v=A.row(1)
    p = u.dot_product(v)
    a=u.norm()
    b=v.norm()
    cs=p/(a*b)
    final_calc = arccos(cs) / (2*pi)
    return final_calc.numerical_approx()

#checking examples in Dr. Zhou's code
sage: sol(A=matrix([[0,1],[1,0]]))                                              
0.250000000000000

sage: sol(A= matrix([[1,0],[-1,1.732]]))                                        
0.333335354946743

# Idea for multiple rays in R^2: arrange from least to greatest according to angle with positive real axis, greatest - smallest

def solid2(u,v,w):
    """ Returns the solid angle spanned by 3 rays in R^2:
        Parameters:
                u=vector([a,b]) is one of the rays, emanating from origin extending through point (a,b)
                v=vector([c,d]) is one of the rays, emanating from origin extending through point (c,d)
                w=vector([e,f]) is one of the rays, emanating from origin extending through point (e,f)

            Returns: final_calc.numerical_approx() the angle spanned by u,v, and w, as a ratio, and in decimal form
    """
    e_1=vector([1,0])
    u_n=u.norm()
    v_n=v.norm()
    w_n=w.norm()
    u_d=u.dot_product(e_1)
    v_d=v.dot_product(e_1)
    w_d=w.dot_product(e_1)
    u_a=arccos(u_d/u_n)
    v_a=arccos(v_d/v_n)
    w_a=arccos(w_d/w_n)
    L=[u_a, v_a, w_a]
    S=sorted(L)
    final_calc=(S[2]-S[0])/(2*pi)
    return final_calc.numerical_approx()

##Checking with Dr. Zhou's examples
sage: solid2(u=vector([1,0]), v=vector([0,1]), w=vector([-1,0]))                
0.500000000000000

sage: solid2(u=vector([1,0]),v=vector([0,1]),w=vector([-1,-1]))                 
0.375000000000000
DOES NOT MATCH, SHOULD BE 1
NEED TO ACCOUNT FOR RAYS IN LOWER HALF PLANE

def solid3(A):
    """ Gives the solid angle at the origin of a simplicial cone in R^3, generated by 3 linearly independent vectors (Beck et al., 2015).
        Parameters:  A = 3x3 matrix with rows representing the 3 linearly independent vectors
    """
    v_0=A.row(0)
    v_1=A.row(1)
    v_2=A.row(2)
    c_0=(v_0.cross_product(v_1).dot_product(v_0.cross_product(v_2)))/((v_0.cross_product(v_1).norm())*(v_0.cross_product(v_2).norm()))
    c_1=(v_1.cross_product(v_0).dot_product(v_1.cross_product(v_2)))/((v_1.cross_product(v_0).norm())*(v_1.cross_product(v_2).norm()))
    c_2=(v_2.cross_product(v_0).dot_product(v_2.cross_product(v_1)))/((v_2.cross_product(v_0).norm())*(v_2.cross_product(v_1).norm()))
    a_0=arccos(c_0)
    a_1=arccos(c_1)
    a_2=arccos(c_2)
    omega=(a_0+a_1+a_2-pi)/(4*pi)
    return omega.numerical_approx()

    EXAMPLES:
    sage:  solid3(A=matrix([[1,0,0],[0,1,0],[0,0,1]]))
0.125000000000000
sage: solid3(A= matrix([[1,0,1],[0,1,1],[0,-1,1]]))
0.0540867239846964
