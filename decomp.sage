load('solid_angle_code.sage')

def pointed_cone_from_projecting_out_lineality(P):
    r"""
    Returns a pointed cone which is orthogonal to the lineality space
    of the cone P.

    INPUT:

    - ``P`` -- a cone represented as a polyhedron

    OUTPUT:

    - a pointed cone orthogonal to the lineality space of ``P`` represented
    as a polyhedron whose base ring is the fraction field of ``P``'s base ring,
    and which has the same backend as ``P``.

    EXAMPLES:

    This example shows how a halspace in \Rr^2, separated by the line
    x_1 - x_2 = 0 is the orthogonal direct sum of the pointed cone generated by
    the ray (1/2, -1/2), and the linear space Span({(1,1)}). Note that
    the base ring of the pointed cone is QQ and has the same backend as the
    halfspace::


        sage: P = Polyhedron(rays = [[1,1],[-1,-1],[1,0]], base_ring=ZZ, backend='normaliz')
        sage: P.Vrepresentation()
        (A vertex at (0, 0),
        A ray in the direction (1, 0),
        A line in the direction (1, 1))
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(1/2, -1/2)]
        sage: PP
        A 1-dimensional polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray
        sage: PP.Vrepresentation()
        (A vertex at (0, 0), A ray in the direction (1, -1))
        sage: [PP.base_ring(), PP.backend()]
        [Rational Field, 'normaliz']

    This example shows that the base ring of the output cone will be the fraction
    field of the base ring of the input cone, and that the output cone will
    have the same backend.::


        sage: P = Polyhedron(rays = [[1,1],[-1,-1],[1,0]], base_ring=ZZ, backend='ppl')
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        sage: [PP.base_ring(), PP.backend()]
        [Rational Field, 'ppl']

    This example shows a nonpointed cone in \Rr^3 may be decomposed into
    a pointed cone generated by rays (1, -1/2, 1/2) and (1, 1/2, -1/2), and
    a line::

        sage: P = Polyhedron(rays=[[1,0,1],[1,0,-1],[1,1,1],[0,1,1],[0,-1,-1]])
        sage: P.Vrepresentation()
        (A line in the direction (0, 1, 1),
        A ray in the direction (1, -1, 0),
        A vertex at (0, 0, 0),
        A ray in the direction (1, 1, 0))
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(1, -1/2, 1/2), (1, 1/2, -1/2)]
        sage: PP.Vrepresentation()
        (A vertex at (0, 0, 0),
        A ray in the direction (2, -1, 1),
        A ray in the direction (2, 1, -1))

    This example shows that when the input cone is pointed (i.e its lineality
    space is the zero vector), the output is itslef.::

        sage: P = Polyhedron(rays=[[1,0],[0,1]])
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(0, 1), (1, 0)]
        sage: PP.Vrepresentation()
        (A vertex at (0, 0),
        A ray in the direction (0, 1),
        A ray in the direction (1, 0))

    .. NOTE::

        A result of Stoer and Witzgall shows that every convex cone P
        is the orthogonal direct sum of its lineality space L = P \cap - P
        and a pointed cone C_p = P \cap L^\perp. Given a polyhedral cone P,
        this function returns C_p
    """
    def proj(v, u):
         a = v.dot_product(u)/(sum(u[i]^2 for i in range(len(u)))) * u
         return a
    if P.lines():
        basering = (P.base_ring()).fraction_field() # because Gram-Schmidt requires division, will change to fraction field
        lin_space_matrix = matrix(basering, P.lines_list())
        # rows of lineality_orthogonal_basis form orthogonal basis of lineality space L
        lineality_orthogonal_basis = (lin_space_matrix.gram_schmidt()[0]).rows()
        new_rays = []
        for ray in P.rays_list():
            ray_vec = vector(basering, ray)
            proj_k_onto_lin_space = vector(basering, [0]*P.ambient_dim())
            for basis_vec in lineality_orthogonal_basis:
                proj_k_onto_lin_space += proj(ray_vec, basis_vec)
            new_rays.append(ray_vec - proj_k_onto_lin_space)
        return Polyhedron(rays = new_rays, base_ring = basering, backend = P.backend())
    else:
        return P