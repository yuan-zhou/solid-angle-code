load('solid_angle_code.sage')

def pointed_cone_from_projecting_out_lineality(P):
    r"""
    Returns a pointed cone which is orthogonal to the lineality space
    of the cone P.

    INPUT:

    - ``P`` -- a cone represented as a polyhedron

    OUTPUT:

    - a pointed cone orthogonal to the lineality space of ``P`` represented
    as a polyhedron whose base ring is the fraction field of ``P``'s base ring,
    and which has the same backend as ``P``.

    EXAMPLES:

    This example shows how a halspace in \Rr^2, separated by the line
    x_1 - x_2 = 0 is the orthogonal direct sum of the pointed cone generated by
    the ray (1/2, -1/2), and the linear space Span({(1,1)}). Note that
    the base ring of the pointed cone is QQ and has the same backend as the
    halfspace::


        sage: P = Polyhedron(rays = [[1,1],[-1,-1],[1,0]], base_ring=ZZ, backend='normaliz')
        sage: P.Vrepresentation()
        (A vertex at (0, 0),
        A ray in the direction (1, 0),
        A line in the direction (1, 1))
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(1/2, -1/2)]
        sage: PP
        A 1-dimensional polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray
        sage: PP.Vrepresentation()
        (A vertex at (0, 0), A ray in the direction (1, -1))
        sage: [PP.base_ring(), PP.backend()]
        [Rational Field, 'normaliz']

    This example shows that the base ring of the output cone will be the fraction
    field of the base ring of the input cone, and that the output cone will
    have the same backend.::


        sage: P = Polyhedron(rays = [[1,1],[-1,-1],[1,0]], base_ring=ZZ, backend='ppl')
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        sage: [PP.base_ring(), PP.backend()]
        [Rational Field, 'ppl']

    This example shows a nonpointed cone in \Rr^3 may be decomposed into
    a pointed cone generated by rays (1, -1/2, 1/2) and (1, 1/2, -1/2), and
    a line::

        sage: P = Polyhedron(rays=[[1,0,1],[1,0,-1],[1,1,1],[0,1,1],[0,-1,-1]])
        sage: P.Vrepresentation()
        (A line in the direction (0, 1, 1),
        A ray in the direction (1, -1, 0),
        A vertex at (0, 0, 0),
        A ray in the direction (1, 1, 0))
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(1, -1/2, 1/2), (1, 1/2, -1/2)]
        sage: PP.Vrepresentation()
        (A vertex at (0, 0, 0),
        A ray in the direction (2, -1, 1),
        A ray in the direction (2, 1, -1))

    This example shows that when the input cone is pointed (i.e its lineality
    space is the zero vector), the output is itslef.::

        sage: P = Polyhedron(rays=[[1,0],[0,1]])
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(0, 1), (1, 0)]
        sage: PP.Vrepresentation()
        (A vertex at (0, 0),
        A ray in the direction (0, 1),
        A ray in the direction (1, 0))

    .. NOTE::

        A result of Stoer and Witzgall shows that every convex cone P
        is the orthogonal direct sum of its lineality space L = P \cap - P
        and a pointed cone C_p = P \cap L^\perp. Given a polyhedral cone P,
        this function returns C_p
    """
    def proj(v, u):
         a = v.dot_product(u)/(sum(u[i]^2 for i in range(len(u)))) * u
         return a
    if P.lines():
        basering = (P.base_ring()).fraction_field() # because Gram-Schmidt requires division, will change to fraction field
        lin_space_matrix = matrix(basering, P.lines_list())
        # rows of lineality_orthogonal_basis form orthogonal basis of lineality space L
        lineality_orthogonal_basis = (lin_space_matrix.gram_schmidt()[0]).rows()
        new_rays = []
        for ray in P.rays_list():
            ray_vec = vector(basering, ray)
            proj_k_onto_lin_space = vector(basering, [0]*P.ambient_dim())
            for basis_vec in lineality_orthogonal_basis:
                proj_k_onto_lin_space += proj(ray_vec, basis_vec)
            new_rays.append(ray_vec - proj_k_onto_lin_space)
        return Polyhedron(rays = new_rays, base_ring = basering, backend = P.backend())
    else:
        return P
    
def triangulation_into_simplicial_cone_matrices(P, decompose_to_tridiag=False):
    r"""
    Returns a list of matrices, each of which has rows corresponding to
    the extreme generators of a simplicial cone in the triangulation of
    the pointed cone P' where ``P `` (not necessarily pointed) is the
    orthogonal direct sum of its lineality space and the pointed cone P'.

    INPUT:

    - ``P`` -- a cone represented as a polyhedron

    OUTPUT:

    - a list of matrices, each representing a simplicial
    cone in the triangulation of P'.

    EXAMPLES:

    In this example, we give a triangulation for a pointed, non-simplicial
    cone in Rr^3 generated by the rays (1, 0, 0), (0, 1, 0), (1, 0, 1), and
    (0, 1, 1). The triangulation contains two cones::

        sage: P = Polyhedron(rays=[[1,0,0],[0,1,0],[1,0,1],[0,1,1]], backend='normaliz')
        sage: list(triangulation_into_simplicial_cone_matrices(P))
        [
        [0 1 0]  [0 1 1]
        [0 1 1]  [1 0 0]
        [1 0 0], [1 0 1]
        ]

    Below we demonstrate the computation of a pointed non-simplicial
    cone in Rr^4 and Rr^5::

        sage: P = Polyhedron(rays=[[1,-1,1,1],[1,-1,0,0],[1,0,0,-1],[1,1,1,0],[1,2,3,4],[-1,2,-3,4]], backend='ppl')
        sage: list(triangulation_into_simplicial_cone_matrices(P))
        [
        [-1  2 -3  4]  [-1  2 -3  4]  [-1  2 -3  4]
        [ 1 -1  0  0]  [ 1 -1  1  1]  [ 1 -1  1  1]
        [ 1 -1  1  1]  [ 1  0  0 -1]  [ 1  1  1  0]
        [ 1  0  0 -1], [ 1  1  1  0], [ 1  2  3  4]
        ]

        sage: P = Polyhedron(rays=[[1,-1,1,1,2],[1,-1,0,0,0],[1,0,0,-1,3],[1,1,1,0,-1],[1,2,3,4,4],[-1,2,-3,4,5],[1,1,1,1,1]], backend='ppl')
        sage: list(triangulation_into_simplicial_cone_matrices(P))
        [
        [-1  2 -3  4  5]  [-1  2 -3  4  5]  [-1  2 -3  4  5]
        [ 1 -1  0  0  0]  [ 1 -1  0  0  0]  [ 1 -1  1  1  2]
        [ 1 -1  1  1  2]  [ 1 -1  1  1  2]  [ 1  0  0 -1  3]
        [ 1  0  0 -1  3]  [ 1  1  1  0 -1]  [ 1  1  1  0 -1]
        [ 1  1  1  0 -1], [ 1  2  3  4  4], [ 1  2  3  4  4]
        ]

    .. NOTE::

        Given a non-pointed cone P, the function
        'pointed_cone_from_projecting_out_lineality' may be used to obtain
        a pointed cone P' such that P is the orthogonal direct sum of its
        lineality space and P'. This function uses the Macaulay2 interface
        and TOPCOM to triangulate the cone P' into simplicial cones.
    """
    curr_min = 1e6

    # Create pointed cone with same solid angle
    pointed_cone = pointed_cone_from_projecting_out_lineality(P)
    rays = matrix(pointed_cone.rays_list())

    # Format for macaulay2 to use Topcom for triangulation
    macaulay2('loadPackage "Topcom"')
    macaulay_input_0 = str('A = transpose matrix {')
    for row in rays.rows():
        row_str = str(row)
        ss = row_str.replace('(','{').replace(')','}')
        macaulay_input_0 += ss
    macaulay_input_0 += str('}')
    macaulay_input = macaulay_input_0.replace('}{','},{')

    macaulay2(macaulay_input)
    Start_Time = time.process_time()
    Ts = macaulay2('topcomAllTriangulations(A, Homogenize => false, Fine => false, RegularOnly => true)')
    Execution_Time = time.process_time() - Start_Time
    print("Enumerating all {} TOPCOM triangulations took {} seconds".format(len(Ts), Execution_Time))

    # Format TOPCOM triangulations list for sage
    Triangulations = []
    for triang in Ts:
        input_string = str(str(triang))
        formatted_string = input_string.replace('{', '[').replace('}', ']')
        output_list = eval(formatted_string)
        Triangulations.append(output_list)
    # Compute number of cones in decomp of each triangulation to determine
    # the triangulation yielding the minimim number
    Start_Time = time.process_time()
    for triangulation in Triangulations:
        if len(triangulation) >= curr_min:
            continue
        triangulation_to_matrix_list = []
        for simplex in triangulation:
            simplicial_cone_matrix = matrix([rays[i] for i in simplex])
            triangulation_to_matrix_list.append(simplicial_cone_matrix)
        num_cones = total_num_cones(triangulation_to_matrix_list, decompose_to_tridiag=decompose_to_tridiag)
        if num_cones < curr_min:
            curr_min = num_cones
            min_cones_triang = triangulation_to_matrix_list
    Execution_Time = time.process_time() - Start_Time
    print("Finding minimum cone decomposition took {} seconds".format(Execution_Time))
    print("INFO: Triangulation decomposes to {} cones".format(curr_min))
    return min_cones_triang