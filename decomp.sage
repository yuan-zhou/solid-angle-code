load('solid_angle_code.sage')

def pointed_cone_from_projecting_out_lineality(P):
    r"""
    Returns a pointed cone which is orthogonal to the lineality space
    of the cone P.

    INPUT:

    - ``P`` -- a cone represented as a polyhedron

    OUTPUT:

    - a pointed cone orthogonal to the lineality space of ``P`` represented
    as a polyhedron whose base ring is the fraction field of ``P``'s base ring,
    and which has the same backend as ``P``.

    EXAMPLES:

    This example shows how a halspace in \Rr^2, separated by the line
    x_1 - x_2 = 0 is the orthogonal direct sum of the pointed cone generated by
    the ray (1/2, -1/2), and the linear space Span({(1,1)}). Note that
    the base ring of the pointed cone is QQ and has the same backend as the
    halfspace::


        sage: P = Polyhedron(rays = [[1,1],[-1,-1],[1,0]], base_ring=ZZ, backend='normaliz')
        sage: P.Vrepresentation()
        (A vertex at (0, 0),
        A ray in the direction (1, 0),
        A line in the direction (1, 1))
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(1/2, -1/2)]
        sage: PP
        A 1-dimensional polyhedron in QQ^2 defined as the convex hull of 1 vertex and 1 ray
        sage: PP.Vrepresentation()
        (A vertex at (0, 0), A ray in the direction (1, -1))
        sage: [PP.base_ring(), PP.backend()]
        [Rational Field, 'normaliz']

    This example shows that the base ring of the output cone will be the fraction
    field of the base ring of the input cone, and that the output cone will
    have the same backend.::


        sage: P = Polyhedron(rays = [[1,1],[-1,-1],[1,0]], base_ring=ZZ, backend='ppl')
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        sage: [PP.base_ring(), PP.backend()]
        [Rational Field, 'ppl']

    This example shows a nonpointed cone in \Rr^3 may be decomposed into
    a pointed cone generated by rays (1, -1/2, 1/2) and (1, 1/2, -1/2), and
    a line::

        sage: P = Polyhedron(rays=[[1,0,1],[1,0,-1],[1,1,1],[0,1,1],[0,-1,-1]])
        sage: P.Vrepresentation()
        (A line in the direction (0, 1, 1),
        A ray in the direction (1, -1, 0),
        A vertex at (0, 0, 0),
        A ray in the direction (1, 1, 0))
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(1, -1/2, 1/2), (1, 1/2, -1/2)]
        sage: PP.Vrepresentation()
        (A vertex at (0, 0, 0),
        A ray in the direction (2, -1, 1),
        A ray in the direction (2, 1, -1))

    This example shows that when the input cone is pointed (i.e its lineality
    space is the zero vector), the output is itslef.::

        sage: P = Polyhedron(rays=[[1,0],[0,1]])
        sage: PP = pointed_cone_from_projecting_out_lineality(P)
        [(0, 1), (1, 0)]
        sage: PP.Vrepresentation()
        (A vertex at (0, 0),
        A ray in the direction (0, 1),
        A ray in the direction (1, 0))

    .. NOTE::

        A result of Stoer and Witzgall shows that every convex cone P
        is the orthogonal direct sum of its lineality space L = P \cap - P
        and a pointed cone C_p = P \cap L^\perp. Given a polyhedral cone P,
        this function returns C_p
    """
    def proj(v, u):
         a = v.dot_product(u)/(sum(u[i]^2 for i in range(len(u)))) * u
         return a
    if P.lines():
        basering = (P.base_ring()).fraction_field() # because Gram-Schmidt requires division, will change to fraction field
        lin_space_matrix = matrix(basering, P.lines_list())
        # rows of lineality_orthogonal_basis form orthogonal basis of lineality space L
        lineality_orthogonal_basis = (lin_space_matrix.gram_schmidt()[0]).rows()
        new_rays = []
        for ray in P.rays_list():
            ray_vec = vector(basering, ray)
            proj_k_onto_lin_space = vector(basering, [0]*P.ambient_dim())
            for basis_vec in lineality_orthogonal_basis:
                proj_k_onto_lin_space += proj(ray_vec, basis_vec)
            new_rays.append(ray_vec - proj_k_onto_lin_space)
        return Polyhedron(rays = new_rays, base_ring = basering, backend = P.backend())
    else:
        return P
    
def triangulation_into_simplicial_cone_matrices(P, decompose_to_tridiag=False):
    r"""
    Returns a list of matrices, each of which has rows corresponding to
    the extreme generators of a simplicial cone in the triangulation of
    the pointed cone P' where ``P `` (not necessarily pointed) is the
    orthogonal direct sum of its lineality space and the pointed cone P'.

    INPUT:

    - ``P`` -- a cone represented as a polyhedron

    OUTPUT:

    - a list of matrices, each representing a simplicial
    cone in the triangulation of P'.

    EXAMPLES:

    In this example, we give a triangulation for a pointed, non-simplicial
    cone in Rr^3 generated by the rays (1, 0, 0), (0, 1, 0), (1, 0, 1), and
    (0, 1, 1). The triangulation contains two cones::

        sage: P = Polyhedron(rays=[[1,0,0],[0,1,0],[1,0,1],[0,1,1]], backend='normaliz')
        sage: list(triangulation_into_simplicial_cone_matrices(P))
        [
        [0 1 0]  [0 1 1]
        [0 1 1]  [1 0 0]
        [1 0 0], [1 0 1]
        ]

    Below we demonstrate the computation of a pointed non-simplicial
    cone in Rr^4 and Rr^5::

        sage: P = Polyhedron(rays=[[1,-1,1,1],[1,-1,0,0],[1,0,0,-1],[1,1,1,0],[1,2,3,4],[-1,2,-3,4]], backend='ppl')
        sage: list(triangulation_into_simplicial_cone_matrices(P))
        [
        [-1  2 -3  4]  [-1  2 -3  4]  [-1  2 -3  4]
        [ 1 -1  0  0]  [ 1 -1  1  1]  [ 1 -1  1  1]
        [ 1 -1  1  1]  [ 1  0  0 -1]  [ 1  1  1  0]
        [ 1  0  0 -1], [ 1  1  1  0], [ 1  2  3  4]
        ]

        sage: P = Polyhedron(rays=[[1,-1,1,1,2],[1,-1,0,0,0],[1,0,0,-1,3],[1,1,1,0,-1],[1,2,3,4,4],[-1,2,-3,4,5],[1,1,1,1,1]], backend='ppl')
        sage: list(triangulation_into_simplicial_cone_matrices(P))
        [
        [-1  2 -3  4  5]  [-1  2 -3  4  5]  [-1  2 -3  4  5]
        [ 1 -1  0  0  0]  [ 1 -1  0  0  0]  [ 1 -1  1  1  2]
        [ 1 -1  1  1  2]  [ 1 -1  1  1  2]  [ 1  0  0 -1  3]
        [ 1  0  0 -1  3]  [ 1  1  1  0 -1]  [ 1  1  1  0 -1]
        [ 1  1  1  0 -1], [ 1  2  3  4  4], [ 1  2  3  4  4]
        ]

    .. NOTE::

        Given a non-pointed cone P, the function
        'pointed_cone_from_projecting_out_lineality' may be used to obtain
        a pointed cone P' such that P is the orthogonal direct sum of its
        lineality space and P'. This function uses the Macaulay2 interface
        and TOPCOM to triangulate the cone P' into simplicial cones.
    """
    curr_min = 1e6

    # Create pointed cone with same solid angle
    pointed_cone = pointed_cone_from_projecting_out_lineality(P)
    rays = matrix(pointed_cone.rays_list())

    # Format for macaulay2 to use Topcom for triangulation
    macaulay2('loadPackage "Topcom"')
    macaulay_input_0 = str('A = transpose matrix {')
    for row in rays.rows():
        row_str = str(row)
        ss = row_str.replace('(','{').replace(')','}')
        macaulay_input_0 += ss
    macaulay_input_0 += str('}')
    macaulay_input = macaulay_input_0.replace('}{','},{')

    macaulay2(macaulay_input)
    Start_Time = time.process_time()
    Ts = macaulay2('topcomAllTriangulations(A, Homogenize => false, Fine => false, RegularOnly => true)')
    Execution_Time = time.process_time() - Start_Time
    print("Enumerating all {} TOPCOM triangulations took {} seconds".format(len(Ts), Execution_Time))

    # Format TOPCOM triangulations list for sage
    Triangulations = []
    for triang in Ts:
        input_string = str(str(triang))
        formatted_string = input_string.replace('{', '[').replace('}', ']')
        output_list = eval(formatted_string)
        Triangulations.append(output_list)
    # Compute number of cones in decomp of each triangulation to determine
    # the triangulation yielding the minimim number
    Start_Time = time.process_time()
    for triangulation in Triangulations:
        if len(triangulation) >= curr_min:
            continue
        triangulation_to_matrix_list = []
        for simplex in triangulation:
            simplicial_cone_matrix = matrix([rays[i] for i in simplex])
            triangulation_to_matrix_list.append(simplicial_cone_matrix)
        num_cones = total_num_cones(triangulation_to_matrix_list, decompose_to_tridiag=decompose_to_tridiag)
        if num_cones < curr_min:
            curr_min = num_cones
            min_cones_triang = triangulation_to_matrix_list
    Execution_Time = time.process_time() - Start_Time
    print("Finding minimum cone decomposition took {} seconds".format(Execution_Time))
    print("INFO: Triangulation decomposes to {} cones".format(curr_min))
    return min_cones_triang

def generate_orthogonal_parts(A):
    r"""
    Return a generator corresponding to the decomposition of the cone into
    orthogonal parts.

    INPUT:

    - ``A`` -- A matrix where the row vectors represent the extreme
    rays/vectors of the cone we wish to decompose.

    OUTPUT:

    - a generator object containing sets of vectors corresponding to
    to a decomposition of the cone given by `A` into orthogonal parts.

    EXAMPLES:

    This example shows how the cone generated by vectors [1,1],[-2,2]
    in \RR^2 decomposes into two orthogonal parts::

        sage: A=matrix([[1,1],[-2,2]])
        sage: list( generate_orthogonal_parts(A))
        [[1 1], [-2  2]]

    The following example shows a cone in \Rr^3 being decomposed into
    orthogonal parts, each of which when viewed in its affine space are
    cones of dimension 2::

        sage: A=matrix([[1,0,0],[0,0,1],[0,1,1],[0,-1,0], [-1,0,0]])
        sage: list( generate_orthogonal_parts(A))
        [
                    [ 0  0  1]
        [ 1  0  0]  [ 0  1  1]
        [-1  0  0], [ 0 -1  0]
        ]


    This example shows a decomposition of a cone in \Rr^3 into three
    orthogonal parts, each of which corresponds to a 1-dimensional cone::

        sage: A=matrix([[1,0,0],[0,0,1],[0,1,0]])
        sage: list( generate_orthogonal_parts(A))
        [[1 0 0], [0 0 1], [0 1 0]]


    This example shows that the function can be used to determine how
    the number of orthogonal parts in a decomposition::

        sage: A=matrix([[0,0,1],[0,1,0],[0,-1,0]])
        sage: len(list(generate_orthogonal_parts(A)))
        2


    .. NOTE::

        This function allows us to decompose higher dimensional cones
        into lower dimensional cones.
    """
    n = A.nrows()
    k = 0
    u_indice_list = [0]
    w_indice_set = set(range(1, n))
    while k < len(u_indice_list):
        i = u_indice_list[k]
        for j in range(n):
            if (j in w_indice_set) and (A[i]*A[j] != 0):
                u_indice_list.append(j)
                w_indice_set.remove(j)
        k += 1
    u = A.delete_rows(w_indice_set)
    yield u
    if w_indice_set:
        w = A.matrix_from_rows(w_indice_set)
        for result in generate_orthogonal_parts(w):
            yield result


def check_sign_consistency(A):
    r"""
    Return whether the associated matrix `M(1, -|\alpha_{ij}|)` for the given
    matrix ``A`` can be expressed as 'V^tV' for some matrix `V`, where V[i] is
    either A[i] or -A[i].

    INPUT:

    - ``A`` -- matrix whose row vectors are extreme rays of a simplicial cone.

    OUTPUT: ``True`` or ``False``.

    EXAMPLES:

    Below is an example of a matrix that is not of the desired form. Note that
    in particular, the associated matrix is not positive definite.::

        sage: A = matrix([[1,-1,0],[2,1,1],[-1,0,0]])
        sage: check_sign_consistency(A)
        False

    Below we see that the function works in higher dimensions::

        sage: A = matrix([[1,2,3,4,5],[-1,3,0,-4,1],[5,0,0,-1,0],
        ....:   [0,0,-2,1,4],[0,0,0,0,1]])
        sage: check_sign_consistency(A)
        False

    The following example shows that although the associated matrix is
    positive definite, it does not satisfy the stronger condition of being
    able to expressed in the desired form::

        sage: logging.disable(logging.INFO)
        sage: A = matrix([[1/2, -1/2, -1/2, 1/2],[1/2, 1/10, 7/10, 1/2],
        ....:   [-4/7, 4/7, 1/7, 4/7],[-4/11, -5/11, 8/11, 4/11]])
        sage: is_M_alpha_posdef(A)
        True
        sage: check_sign_consistency(A)
        False


    Below we see an example corresponding to a cone whose associated matrix
    can be expressed in the desired form::

        sage: A = matrix([[1,1,0,0,0],[-1,3,0,-4,1],[5,0,0,-1,0],
        ....:   [0,0,-2,1,4],[0,0,0,0,1]])
        sage: check_sign_consistency(A)
        True

    .. NOTE::

        This function provides a sufficient condition for positive
        definiteness of the associated matrix, so that in particular, when
        the function returns 'True', the cone corresponding to ``A`` has a
        solid angle that can be computed using Ribando's multivariate
        hypergeometric series formula.
    """
    n = A.nrows()
    s = [0]*n
    for i in range(n):
        if s[i] == 0:
            s[i] = 1
        for j in range(i+1, n):
            if A[i] * A[j] < 0:
                if s[j] == -s[i]:
                    return False
                s[j] = s[i]
            elif A[i] * A[j] > 0:
                if s[j] == s[i]:
                    return False
                s[j] = -s[i]
    return True


def generate_cones_decomposition(A, h=None, w=None, s=1, tridiag=False):
    r"""
    Return a a list of pairs corresponding to the decomposition of the cone
    into a finite family of cones, each with a solid angle that is
    computable via the Ribando normalized solid angle formula.

    INPUT:

    - ``A`` -- A matrix where the row vectors represent the extreme
    rays/vectors of the cone we wish to decompose.

    - ``h`` -- integer; (optional) ``h`` is the index of the row vector
    in the cone matrix which determines an edge of each cone in the
    decomposition.

    - ``w`` -- matrix; (optional) ``w`` is a matrix with vectors that we
    insist on being in each cone of the decomposition. That is, `w` deter-
    mines a face that is in each of the cones in the decompositon.
    Unlike the parameter `h`, this parameter can correspond to an arbitrary
    subcone and does not have to relate to the input matrix.

    OUTPUT:

    - a list containing pairs `(C_sigma, s)` where `C_sigma` is a
    cone in the decomposition of the cone corresponding to `A` and `s` is
    either 1 or -1, depending on the sign of the cone based on Brion-Vergne
    decomposition.

    EXAMPLES:

    This example shows how the cone generated by vectors [1,-1,0],[2,1,1],
    [-1,0,0] in \RR^3 decomposes into the sum of two cones::

        sage: A=matrix([[1,-1,0],[2,1,1],[-1,0,0]])
        sage: list(generate_cones_decomposition(A))
        [(
        [ 1 -1  0]
        [ 2  1  1]
        [ 1  1  1], 1
        ),
        (
        [ 1 -1  0]
        [-1  0  0]
        [ 1  1  1], 1
        )]

    The following example shows a cone in \Rr^3 being decomposed into
    the difference of two cones::

        sage: A=matrix([[1,2,3],[1,0,1],[1,1,1]])
        sage: list(generate_cones_decomposition(A, tridiag=False))
        [(
        [   1    2    3]
        [   1    0    1]
        [-1/2    1 -1/2], 1
        ),
        (
        [   1    2    3]
        [   1    1    1]
        [-1/3  2/3 -1/3], -1
        )]

    This example showcases how the parameter `h` affects the decom-
    position::

        sage: A=matrix([[1,1,1],[-2,-1,0],[-2,0,-1]])
        sage: list(generate_cones_decomposition(A))
        [(
        [ 1  1  1]
        [-2 -1  0]
        [ 0 -1  1], -1
        ),
        (
        [ 1  1  1]
        [-2  0 -1]
        [ 0 -1  1], 1
        )]


        sage: list(generate_cones_decomposition(A, h=2))
        [(
        [  -2    0   -1]
        [   1    1    1]
        [-2/3  1/3  4/3], 1
        ),
        (
        [  -2    0   -1]
        [  -2   -1    0]
        [-1/2  1/4    1], 1
        )]

    Below we show how the parameter `w` affects the decomposition::

        sage: A=matrix([[1,1,1],[-2,-1,0],[-2,0,-1]])
        sage: list(generate_cones_decomposition(A, w=matrix([A[1]])))
        [(
        [-2 -1  0]
        [ 1  1  1]
        [-2 -1  0]
        [ 0 -1  1], -1
        ),
        (
        [-2 -1  0]
        [ 1  1  1]
        [-2  0 -1]
        [ 0 -1  1], 1
        )]


        sage: list(generate_cones_decomposition(A, w=matrix([[0,0,1]])))
        [(
        [ 0  0  1]
        [ 1  1  1]
        [-2 -1  0]
        [ 0 -1  1], -1
        ),
        (
        [ 0  0  1]
        [ 1  1  1]
        [-2  0 -1]
        [ 0 -1  1], 1
        )]


    In the following examples, we see that when the input corresponds
    to a cone whose associated matrix is of the form V^tV, as determined
    by the check_sign_consistency function, the decomposition consists of
    the cone itself::

        sage: A=matrix([[1,0,0],[0,0,1],[0,1,0]])
        sage: check_sign_consistency(A)
        True
        sage: list(generate_cones_decomposition(A))
        [(
        [1 0 0]
        [0 0 1]
        [0 1 0], 1
        )]

        sage: A=matrix([[1,1,1],[1,-1,0],[-2,0,0]])
        sage: list(generate_cones_decomposition(A))
        [(
        [ 1  1  1]
        [ 1 -1  0]
        [-2  0  0], 1
        )]


    This example below shows that the function can be used to determine
    how many cones are in a decomposition::

        sage: A=matrix([[1,1,1],[-2,-1,0],[-2,0,-1]])
        sage: len(list(generate_cones_decomposition(A)))
        2

    In this example, we see that the function works in higher dimensions.
    Here, a cone in \RR^4 is decomposed into 4 cones:

    sage: A= matrix([[1,-1,-1,1],[5,1,7,5],[-4,4,1,4],[-4,-5,8,4]])
    sage: list(generate_cones_decomposition(A))
    [(
    [      1      -1      -1       1]
    [      5       1       7       5]
    [   17/2    13/2    37/2    33/2]
    [-265/87 -740/87  370/87  -35/29], 1
    ),
    (
    [      1      -1      -1       1]
    [      5       1       7       5]
    [    7/2    -7/2    37/2    23/2]
    [-265/67 -740/67  370/67 -105/67], -1
    ),
    (
    [    1    -1    -1     1]
    [   -4     4     1     4]
    [ 17/5  13/5  37/5  33/5]
    [  8/5  37/5 -37/5  -8/5], -1
    ),
    (
    [     1     -1     -1      1]
    [    -4     -5      8      4]
    [   7/3   -7/3   37/3   23/3]
    [465/79 720/79 370/79 625/79], 1
    ),
    (
    [      1      -1      -1       1]
    [     -4      -5       8       4]
    [    8/3    37/3   -37/3    -8/3]
    [465/109 720/109 370/109 625/109], 1
    )]


    .. NOTE::

        This functions allows us to decompose cones that have solid
        angles that cannot be computed using Ribando's formula into
        cones with computable solid angles. It uses Brion Vergne
        decomposition with respect to a line.
    """
    if (A.nrows() <= 2) or ((not tridiag) and (check_sign_consistency(A))):
        if w is None:
            yield((A, s))
        else:
            yield((w.stack(A), s))
    else:
        n = A.nrows()
        if h is None:
            max_num_orth = -1
            for i in range(n):
                num_orth = [A[i]*A[j] for j in range(n)].count(0)
                if num_orth > max_num_orth:
                    max_num_orth = num_orth
                    h = i
        if w is None:
            ww = matrix(A[h])
        else:
            ww = w.stack(A[h])
        num_orth = [A[h]*A[j] for j in range(n)].count(0)
        if num_orth == n-1:
            u = A.delete_rows([h])
            for vs in generate_cones_decomposition(u, h=None, w=ww, s=s,
                                                   tridiag=tridiag):
                yield vs
        else:
            for i in range(n):
                if (i == h) or (A[i]*A[h] == 0):
                    continue
                u = matrix(A[i])
                if A[i]*A[h] > 0:
                    si = s
                    for j in range(i):
                        if (j != h) and (A[j]*A[h] > 0):
                            si = -si
                    for k in range(n):
                        if (k == h) or (k == i):
                            continue
                        if (k < i) and (A[k]*A[h] > 0):
                            eik = -1
                        else:
                            eik = 1
                        projvk = A[k]-(A[k]*A[h])/(A[i]*A[h]) * A[i]
                        u = u.stack(eik * projvk)
                    for vs in generate_cones_decomposition(u, h=0, w=ww, s=si,
                                                           tridiag=tridiag):
                        yield vs
                elif A[i]*A[h] < 0:
                    si = s
                    for j in range(i+1, n):
                        if (j != h) and (A[j]*A[h] < 0):
                            si = -si
                    for k in range(n):
                        if (k == h) or (k == i):
                            continue
                        if (k > i) and (A[k]*A[h] < 0):
                            eik = -1
                        else:
                            eik = 1
                        projvk = A[k]-(A[k]*A[h])/(A[i]*A[h]) * A[i]
                        u = u.stack(eik * projvk)
                    for vs in generate_cones_decomposition(u, h=0, w=ww, s=si,
                                                           tridiag=tridiag):
                        yield vs


def generate_tridiag_cones_decomposition(A, h=None, w=None, s=1):
    r"""
    Return a a list of pairs corresponding to the decomposition of the cone
    into a finite family of cones, each with a solid angle that is
    computable via the Ribando normalized solid angle formula.

    INPUT:

    - ``A`` -- A matrix where the row vectors represent the extreme
    rays/vectors of the cone we wish to decompose.

    - ``h`` -- integer; (optional) ``h`` is the index of the row vector
    in the cone matrix which determines an edge of each cone in the
    decomposition.

    - ``w`` -- matrix; (optional) ``w`` is a matrix with vectors that we
    insist on being in each cone of the decomposition. That is, `w` deter-
    mines a face that is in each of the cones in the decompositon.
    Unlike the parameter `h`, this parameter can correspond to an arbitrary
    subcone and does not have to relate to the input matrix.

    OUTPUT:

    - a list containing pairs `(C_sigma, s)` where `C_sigma` is a
    cone in the decomposition of the cone corresponding to `A` and `s` is
    either 1 or -1, depending on the sign of the cone based on Brion-Vergne
    decomposition. Each `C_sigma` has a tridiagonal associated matrix.

    EXAMPLES:

    This function is similar to generate_cones_decomposition, however it
    continues to decompose until all the cones have tridiagonal associated
    matrices, unlike generate_cones_decomposition which stops when the
    associated matrix is positive definite. This is demonstrated below::

        sage: A = matrix([[-1,-33,2,-1,-2],[-1,0,1,0,4],[-1,0,3,-1,-8],[4,-1,0,-4,1],[1,1,7,0,3]])
        sage: L = list(generate_cones_decomposition(A))
        sage: len(L)
        11
        sage: vtv(L[5][0])
        [                 1.0  -0.7620634755325443                  0.0                  0.0                  0.0]
[ -0.7620634755325443                  1.0  0.03705044586012998  -0.1584236068762679   0.5510064338758125]
[                 0.0  0.03705044586012998                  1.0  0.16823409295260094 -0.06028966215690933]
[                 0.0  -0.1584236068762679  0.16823409295260094                  1.0 0.015864940226165674]
[                 0.0   0.5510064338758125 -0.06028966215690933 0.015864940226165674                  1.0]

        sage: r = list(generate_tridiag_cones_decomposition(A))
        sage: len(r)
        18
    """
    if A.nrows() <= 2:
        if w is None:
            yield((A, s))
        else:
            yield((w.stack(A), s))
    else:
        n = A.nrows()
        if h is None:
            max_num_orth = -1
            for i in range(n):
                num_orth = [A[i]*A[j] for j in range(n)].count(0)
                if num_orth > max_num_orth:
                    max_num_orth = num_orth
                    h = i
        if w is None:
            ww = matrix(A[h])
        else:
            ww = w.stack(A[h])
        num_orth = [A[h]*A[j] for j in range(n)].count(0)
        if num_orth == n-1:
            u = A.delete_rows([h])
            for vs in generate_tridiag_cones_decomposition(u, h=None, w=ww, s=s):
                yield vs
        else:
            for i in range(n):
                if (i == h) or (A[i]*A[h] == 0):
                    continue
                u = matrix(A[i])
                if A[i]*A[h] > 0:
                    si = s
                    for j in range(i):
                        if (j != h) and (A[j]*A[h] > 0):
                            si = -si
                    for k in range(n):
                        if (k == h) or (k == i):
                            continue
                        if (k < i) and (A[k]*A[h] > 0):
                            eik = -1
                        else:
                            eik = 1
                        projvk = A[k]-(A[k]*A[h])/(A[i]*A[h]) * A[i]
                        u = u.stack(eik * projvk)
                    for vs in generate_tridiag_cones_decomposition(u, h=0, w=ww, s=si):
                        yield vs
                elif A[i]*A[h] < 0:
                    si = s
                    for j in range(i+1, n):
                        if (j != h) and (A[j]*A[h] < 0):
                            si = -si
                    for k in range(n):
                        if (k == h) or (k == i):
                            continue
                        if (k > i) and (A[k]*A[h] < 0):
                            eik = -1
                        else:
                            eik = 1
                        projvk = A[k]-(A[k]*A[h])/(A[i]*A[h]) * A[i]
                        u = u.stack(eik * projvk)
                    for vs in generate_tridiag_cones_decomposition(u, h=0, w=ww, s=si):
                        yield vs

def solid_angle_measure(simplicial_cones_matrices, deg=100000, eps=1e-6, base_ring=RR, decompose_to_tridiag=False, verbose=False):
    r"""
    Return an estimate of the sum of the normalized solid angle measure of the
    cones generated by the row vectors of the matrices in the given list of
    matrices, based on a truncated form of Jason Ribando's formula (see note).

    INPUT:

    - ``simplicial_cones_matrices`` -- a list of matrices whose row vectors span
    the cones of interest.

    - ``eps`` -- positive real number (default: ``1e-6``); this parameter
      is used to determine when the summation stops. In terms of the partial
      sum, when `0.5(s_n-s_{n-1}) < \epsilon / (total number of cones from
      the decomposition)`, we stop adding terms to the partial sum sequence
      from Ribando's formula.

    - ``deg`` -- integer (default: `100`); ``deg`` is the maximum sum of the
      powers of the `\alpha_{ij}`'s in the summation (i.e. it is the maximum
      sum of the terms in the multiexponent.)

    - ``base_ring`` -- a ring (default: `QQ`); the base ring in which to cast
    the dot products on which the formula is based.

    - ``decompose_to_tridiag`` -- a Boolean (default: `False`); whether to
    decompose each given simplicial cone into cones with tridiagonal matrices

    - ``verbose`` -- a Boolean (default: `False`); whether to print information
    on the partial sum sequence

    OUTPUT:

    - an estimate of the sum of the normalized solid angle measures of the given
    simplicial cones

    EXAMPLES:

    This example shows the measure of the solid angle spanned by the vectors
    ``[1,0]`` and ``[-1,-1]``. Note that it agrees with the value obtained by
    the arctan formula.::

        sage: logging.disable(logging.INFO)
        sage: A = [matrix([[1,0],[-1,-1]])]
        sage: solid_angle_measure(A, eps=1e-6)
        0.374998211389711

    This example shows the measure of the solid angle spanned by
    the vectors ``[2, sqrt(2), 3], [-1, 1, 2]``, and ``[-3, 0, 5/4]``, with
    ``deg`` set to ``20`` and ``eps`` set to ``1e-6``. The relative error
    compared to value ``0.01183`` obtained by the arctan formula is <0.5%.::

        sage: A = [matrix([[2, sqrt(2), 3], [-1, 1, 2], [-3, 0, 5/4]])]
        sage: a = solid_angle_measure(A, deg=50, eps=1e-6)
        sage: b = solid_angle_3d(A[0])
        sage: abs(a-b)/b < 5e-5
        True

    The following example demonstrates that the function returns the
    solid angle measure taken with respect to the affine space of the cone
    and so is never 0.::

        sage: A = [matrix([[1,0,0],[0,1,0]])]
        sage: sage: solid_angle_measure(A)
        0.250000000000000

        sage: A = [matrix([[1,1,0],[-1,1,0],[1,0,0]])]
        sage: solid_angle_measure(A, space="ambient")
        WARNING: cone not full-dimensional
        WARNING: cone not full-dimensional
        0

        sage: solid_angle_measure(A, space="affine")
        0.3750003197347264

    This following example demonstrates how the function gives a meaningful
    estimate of the normalized solid angle measure, even when the associated
    matrix is not positive definite, by showing the relative error is <0.5%.::

        sage: A = [matrix([[1,-1,0],[2,1,1],[-1,0,0]])]
        sage: is_M_alpha_posdef(A)
        False
        sage: a = solid_angle_3d(A)
        sage: b = solid_angle_measure(A)
        sage: abs(a-b)/b < 0.005
        True

    This example demonstrates how to obtain the solid angle measures for
    non-simplicial cones. The expected result based on the ``solid_angle_3d``
    function is ``0.40641647...``::

        sage: A = matrix([[1,0,0],[-1,0,0],[-1,2,3],[1,0,-1]])
        sage: P = Polyhedron(rays=A.rows(), backend='normaliz')
        sage: triang = list(triangulation_into_simplicial_cone_matrices(P))
        sage: solid_angle_measure(triang)
        0.406048743652743

    The following are examples of estimations of the solid angle measure of a
    cone in `\RR^5` using different ``deg`` values::

        sage: A = [matrix([[1,1,0,0,0],[-1,3,0,-4,1],[5,0,0,-1,0], [0,0,-2,1,4],[0,0,0,0,1]])]
        sage: solid_angle_measure(A, deg=10)
        0.00533087907335968

        sage: solid_angle_measure(A, deg=12)
        0.00487047236050033

        sage: solid_angle_measure(A, deg=18) # long time (135.75 s)
        0.00407911422649577

    TESTS:

    In the following examples, we consider cones formed by Coxeter arrange-
    ments in various dimensions of various types. The hyperplanes of a Cox-
    eter arrangement of type ``B_n`` subdivide ``R^n`` into ``n!*2^n`` iso-
    metric cones, each with normalized solid angle measure ``1/(n!*2^n)``.

    We consider cones formed by the ``B_2`` arrangement in ``R^2``. The ex-
    pected value is ``1/(2!*2^2)=1/8``::

        sage: B2 = [matrix([[1,1],[1,0]])]
        sage: solid_angle_measure(B2)
        0.125000319734726

    We consider cones formed by the ``B_3`` arrangement in ``R^3``. The ex-
    pected value is ``1/(3!*2^3)=1/48``::

        sage: B3 = [matrix([[1,0,0],[1,1,0],[1,1,1]])]
        sage: solid_angle_measure(B3)
        0.0208333055726408

    We consider cones formed by the ``B_4`` arrangement in ``R^4``. The ex-
    pected value is ``1/(4!*2^4)=1/384``::

        sage: B4 = [matrix([[1,0,0,0],[1,1,0,0],[1,1,1,0],[1,1,1,1]])]
        sage: solid_angle_measure(B4)
        0.00260379843737115

    The hyperplanes of a Coxeter arrangement of type ``D_n`` (n at least 4)
    subdivide ``R^n`` into ``n!*2^(n-1)`` isometric cones, each with normalized
    solid angle measure ``1/(n!*2^(n-1))``.

    We consider cones formed by the ``D_4`` arrangement in ``R^4``. The ex-
    pected value is ``1/(4!*2^3)=1/192``::

        sage: D4 = [matrix(weyl_chamber('D', 4))]
        sage: solid_angle_measure(D4, eps=1e-3)
        0.00540440626056040

    .. NOTE::

        The input of this function should be a list of simplicial cones. This
        function uses the formula given in Ribando's 2006 paper entitled
        "Measuring Solid Angles Beyond Dimension Three." More specifically, it
        is a truncated form of the multi-variate hypergeometric series given in
        Theorem 2.2. The hypergeometric series converges to the normalized
        solid angle measure if and only if the associated matrix to the cone is
        positive definite. This function decomposes the cone of interest into
        cones with positive definite associated matrices, hence into cones
        whose solid angles are computable via Ribando's formula.
    """
    num_cones = total_num_cones(simplicial_cones_matrices, decompose_to_tridiag=decompose_to_tridiag)
    if verbose:
        print("There are {} cones in the decomposition.".format(num_cones))
    eps_prime = eps/num_cones
    angles_to_add = []
    for simplicial_cone in simplicial_cones_matrices:
        solid_angle_factors = []
        orthogonal_parts = list(generate_orthogonal_parts(simplicial_cone))
        for orth_cone in orthogonal_parts:
            if decompose_to_tridiag is True:
                if verbose is True:
                    print(list(generate_tridiag_cones_decomposition(orth_cone)))
                t = sum(s*solid_angle_simplicial_and_posdef(c, deg=deg, eps=eps_prime, base_ring=base_ring, space="affine", tridiag=True, verbose=verbose)
                    for (c, s) in generate_tridiag_cones_decomposition(orth_cone))
            else:
                if is_M_alpha_posdef(orth_cone) == True:
                    if verbose is True:
                        print([orth_cone, 1])
                    t = solid_angle_simplicial_and_posdef(orth_cone, deg=deg, eps=eps_prime, base_ring=base_ring, space="affine", tridiag=False, verbose=verbose)
                else:
                    if verbose is True:
                        print(list(generate_cones_decomposition(orth_cone)))
                    t = sum(s*solid_angle_simplicial_and_posdef(c, deg=deg, eps=eps_prime, base_ring=base_ring, space="affine", verbose=verbose)
                        for (c, s) in generate_cones_decomposition(orth_cone))
            solid_angle_factors.append(t)
        angles_to_add.append(prod(solid_angle_factors))
    print(sum(angles_to_add))
    return(sum(angles_to_add))