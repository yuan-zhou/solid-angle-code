def generate_orthogonal_parts(A):
    r"""
    Return a generator corresponding to the decomposition of the cone into
    orthogonal parts.

    INPUT:

    - ``A`` -- A matrix where the row vectors represent the three extreme
    rays/vectors of the cone we wish to decompose.

    OUTPUT:

    - a generator object containing sets of vectors corresponding to
    to a decomposition of the cone given by A into orthogonal parts.

    EXAMPLES:

    This example shows how the cone generated by vectors [1,1],[-2,2]
    in \RR^2 decomposes into two orthogonal parts::

        sage: A=matrix([[1,1],[-2,2]])
        sage: list( generate_orthogonal_parts(A))
        [[1 1], [-2  2]]

    The following example shows a cone in \Rr^3 being decomposed into
    orthogonal parts, each of which when viewed in its affine space are
    cones of dimension 2::

        sage: A=matrix([[1,0,0],[0,0,1],[0,1,1],[0,-1,0], [-1,0,0]])
        sage: list( generate_orthogonal_parts(A))
        [
                    [ 0  0  1]
        [ 1  0  0]  [ 0  1  1]
        [-1  0  0], [ 0 -1  0]
        ]


    This example shows a decomposition of a cone in \Rr^3 into three
    orthogonal parts, each of which correpsonds to a 1-dimensional cone::

        sage: A=matrix([[1,0,0],[0,0,1],[0,1,0]])
        sage: list( generate_orthogonal_parts(A))
        [[1 0 0], [0 0 1], [0 1 0]]


    This example shows that the function can be used to determine how
    the number of orthogonal parts in a decomposition::

        sage: A=matrix([[0,0,1],[0,1,0],[0,-1,0]])
        sage: len(list(generate_orthogonal_parts(A)))
        2


    .. NOTE::

        This function allows us to decompose higher dimensional cones
        into lower dimensional cones, where the solid angle measure can
        be computed faster.
    """
    n = A.nrows()
    k = 0
    u_indice_list = [0]
    w_indice_set = set(range(1, n))
    while k < len(u_indice_list):
        i = u_indice_list[k]
        for j in range(n):
            if (j in w_indice_set) and (A[i]*A[j] != 0):
                u_indice_list.append(j)
                w_indice_set.remove(j)
        k += 1
    u = A.delete_rows(w_indice_set)
    yield u
    if w_indice_set:
        w = A.matrix_from_rows(w_indice_set)
        for result in generate_orthogonal_parts(w):
            yield result


def check_sign_consistency(A):
    r"""
    Return whether the associated matrix `M(1, -|\alpha_{ij}|)` for the given
    matrix ``A`` is positive definite or not (see note).

    INPUT:

    - ``A`` -- matrix whose row vectors span a simplicial cone.

    OUTPUT: ``True`` or ``False``.

    EXAMPLES:

    This example shows how::

        sage: A = matrix([[1,-1,0],[2,1,1],[-1,0,0]])  #matches posdef
        sage: check_sign_consistency(A)
        False

    The following example shows::

        sage: A = matrix([[1,2,3,4,5],[-1,3,0,-4,1],[5,0,0,-1,0],
        ....:   [0,0,-2,1,4],[0,0,0,0,1]]) #matches
        sage: check_sign_consistency(A)
        False

    The following example shows::

        sage: A = matrix([[1/2, -1/2, -1/2, 1/2],[1/2, 1/10, 7/10, 1/2],
        ....:   [-4/7, 4/7, 1/7, 4/7],[-4/11, -5/11, 8/11, 4/11]]) #not
        sage: check_sign_consistency(A)
        False


    This example shows::

        sage: A = matrix([[1,1,0,0,0],[-1,3,0,-4,1],[5,0,0,-1,0],
        ....:   [0,0,-2,1,4],[0,0,0,0,1]]) #matches
        sage: check_sign_consistency(A)
        True

    .. NOTE::

        This function determines whether the associated matrix
        is positive definite or not by checking if it can be
        expressed in the form "V^tV" for some matrix "V",
        where V[i]= A[i] or -A[i].
    """
    n = A.nrows()
    s = [0]*n
    for i in range(n):
        if s[i] == 0:
            s[i] = 1
        for j in range(i+1, n):
            if A[i] * A[j] < 0:
                if s[j] == -s[i]:
                    return False
                s[j] = s[i]
            elif A[i] * A[j] > 0:
                if s[j] == s[i]:
                    return False
                s[j] = -s[i]
    return True


def generate_cones_decomposition(A, h=None, w=None, s=1, tridiag=False):
    r"""
        Return a a list of pairs corresponding to the decomposition of the cone
        into a family of cones, each with a solid angle that is computable via
        the Ribando normalized solid angle formula.

        INPUT:

        - ``A`` -- A matrix where the row vectors represent the three extreme
        rays/vectors of the cone we wish to decompose.

        - ``h`` -- integer; (optional) ``h`` is the index of the row vector in
        the cone matrix which we designate as special and insist on it being in
        each cone in the decomposition.

        - ``w`` -- matrix; (optional) ``w`` is a matrix with vectors that we
        insist on being in each cone of the decomposition. That is, `w` deter-
        mines a subcone that is in each of the cones in the decompositon.
        Unlike the parameter `h`, this parameter can correspond to an arbitrary
        subcone and does not have to relate to the input matrix.

        - ``s`` -- (optional) ``s`` is either 1 or -1 and determines the signs
        for the indicator functions of the cones in the decomposition.

        OUTPUT:

        - a list containing pairs (C_sigma, s) where C_sigma is a
        cone in the decomposition of the cone corresponding to A and s is
        either 1 or -1, depending on the sign of the cone based on Brion-Vergne
        decomposition.

        EXAMPLES:

        This example shows how the cone generated by vectors [1,-1,0],[2,1,1],
        [-1,0,0] in \RR^3 decomposes into the sum of two cones::

            sage: A=matrix([[1,-1,0],[2,1,1],[-1,0,0]])
            sage: list(generate_cones_decomposition(A))
            [(
            [ 1 -1  0]
            [ 2  1  1]
            [ 1  1  1], 1
            ),
            (
            [ 1 -1  0]
            [-1  0  0]
            [ 1  1  1], 1
            )]

        The following example shows a cone in \Rr^3 being decomposed into
        the difference of two cones::

            sage: A=matrix([[1,2,3],[1,0,1],[1,1,1]])
            sage: list(generate_cones_decomposition(A, tridiag=False))
            [(
            [   1    2    3]
            [   1    0    1]
            [-1/2    1 -1/2], 1
            ),
            (
            [   1    2    3]
            [   1    1    1]
            [-1/3  2/3 -1/3], -1
            )]

        This example showcases how the parameter `h` affects the decom-
        position::

            sage: A=matrix([[1,1,1],[-2,-1,0],[-2,0,-1]])
            sage: list(generate_cones_decomposition(A))
            [(
            [ 1  1  1]
            [-2 -1  0]
            [ 0 -1  1], -1
            ),
            (
            [ 1  1  1]
            [-2  0 -1]
            [ 0 -1  1], 1
            )]


            sage: list(generate_cones_decomposition(A, h=2))
            [(
            [  -2    0   -1]
            [   1    1    1]
            [-2/3  1/3  4/3], 1
            ),
            (
            [  -2    0   -1]
            [  -2   -1    0]
            [-1/2  1/4    1], 1
            )]

        Below we show how the parameter `w` affects the decomposition::

            sage: A=matrix([[1,1,1],[-2,-1,0],[-2,0,-1]])
            sage: list(generate_cones_decomposition(A, w=matrix([A[1]])))
            [(
            [-2 -1  0]
            [ 1  1  1]
            [-2 -1  0]
            [ 0 -1  1], -1
            ),
            (
            [-2 -1  0]
            [ 1  1  1]
            [-2  0 -1]
            [ 0 -1  1], 1
            )]


            sage: list(generate_cones_decomposition(A, w=matrix([[0,0,1]])))
            [(
            [ 0  0  1]
            [ 1  1  1]
            [-2 -1  0]
            [ 0 -1  1], -1
            ),
            (
            [ 0  0  1]
            [ 1  1  1]
            [-2  0 -1]
            [ 0 -1  1], 1
            )]

        Below, we show how the parameter `s` affects the decomposition. Note
        that in particular, the signs of the cones are reversed::

            sage: A=matrix([[1,-1,0],[2,1,1],[-1,0,0]])
            sage: list(generate_cones_decomposition(A, s=1))
            [(
            [ 1 -1  0]
            [ 2  1  1]
            [ 1  1  1], 1
            ),
            (
            [ 1 -1  0]
            [-1  0  0]
            [ 1  1  1], 1
            )]

            sage: list(generate_cones_decomposition(A, s=-1))
            [(
            [ 1 -1  0]
            [ 2  1  1]
            [ 1  1  1], -1
            ),
            (
            [ 1 -1  0]
            [-1  0  0]
            [ 1  1  1], -1
            )]


        In the following examples, we see that when the input corresponds
        to a cone whose associated matrix is of the form V^tV, as determined
        by the check_sign_consistency function, the decomposition consists of
        the cone itself::

            sage: A=matrix([[1,0,0],[0,0,1],[0,1,0]])
            sage: check_sign_consistency(A)
            True
            sage: list(generate_cones_decomposition(A))
            [(
            [1 0 0]
            [0 0 1]
            [0 1 0], 1
            )]

            sage: A=matrix([[1,1,1],[1,-1,0],[-2,0,0]])
            sage: list(generate_cones_decomposition(A))
            [(
            [ 1  1  1]
            [ 1 -1  0]
            [-2  0  0], 1
            )]


        This example below shows that the function can be used to determine
        how many cones are in a decomposition::

            sage: A=matrix([[1,1,1],[-2,-1,0],[-2,0,-1]])
            sage: len(list(generate_cones_decomposition(A)))
            2

        In this example, we see that the function works in higher dimensions.
        Here, a cone in \RR^4 is decomposed into 4 cones:

        sage: A= matrix([[1,-1,-1,1],[5,1,7,5],[-4,4,1,4],[-4,-5,8,4]])
        sage: list(generate_cones_decomposition(A))
        [(
        [      1      -1      -1       1]
        [      5       1       7       5]
        [   17/2    13/2    37/2    33/2]
        [-265/87 -740/87  370/87  -35/29], 1
        ),
        (
        [      1      -1      -1       1]
        [      5       1       7       5]
        [    7/2    -7/2    37/2    23/2]
        [-265/67 -740/67  370/67 -105/67], -1
        ),
        (
        [    1    -1    -1     1]
        [   -4     4     1     4]
        [ 17/5  13/5  37/5  33/5]
        [  8/5  37/5 -37/5  -8/5], -1
        ),
        (
        [     1     -1     -1      1]
        [    -4     -5      8      4]
        [   7/3   -7/3   37/3   23/3]
        [465/79 720/79 370/79 625/79], 1
        ),
        (
        [      1      -1      -1       1]
        [     -4      -5       8       4]
        [    8/3    37/3   -37/3    -8/3]
        [465/109 720/109 370/109 625/109], 1
        )]


        .. NOTE::

            This functions allows us to decompose cones that have solid
            angles that cannot be computed using Ribando's formula into
            cones with computable solid angles. It uses a variation of
            Brion Vergne decomposition with respect to a hyperplane.
        """
    if (A.nrows() <= 2) or ((not tridiag) and (check_sign_consistency(A))):
        if w is None:
            yield((A, s))
        else:
            yield((w.stack(A), s))
    else:
        n = A.nrows()
        if h is None:
            max_num_orth = -1
            for i in range(n):
                num_orth = [A[i]*A[j] for j in range(n)].count(0)
                if num_orth > max_num_orth:
                    max_num_orth = num_orth
                    h = i
        if w is None:
            ww = matrix(A[h])
        else:
            ww = w.stack(A[h])
        num_orth = [A[h]*A[j] for j in range(n)].count(0)
        if num_orth == n-1:
            u = A.delete_rows([h])
            for vs in generate_cones_decomposition(u, h=None, w=ww, s=s,
                                                   tridiag=tridiag):
                yield vs
        else:
            for i in range(n):
                if (i == h) or (A[i]*A[h] == 0):
                    continue
                u = matrix(A[i])
                if A[i]*A[h] > 0:
                    si = s
                    for j in range(i):
                        if (j != h) and (A[j]*A[h] > 0):
                            si = -si
                    for k in range(n):
                        if (k == h) or (k == i):
                            continue
                        if (k < i) and (A[k]*A[h] > 0):
                            eik = -1
                        else:
                            eik = 1
                        projvk = A[k]-(A[k]*A[h])/(A[i]*A[h]) * A[i]
                        u = u.stack(eik * projvk)
                    for vs in generate_cones_decomposition(u, h=0, w=ww, s=si,
                                                           tridiag=tridiag):
                        yield vs
                elif A[i]*A[h] < 0:
                    si = s
                    for j in range(i+1, n):
                        if (j != h) and (A[j]*A[h] < 0):
                            si = -si
                    for k in range(n):
                        if (k == h) or (k == i):
                            continue
                        if (k > i) and (A[k]*A[h] < 0):
                            eik = -1
                        else:
                            eik = 1
                        projvk = A[k]-(A[k]*A[h])/(A[i]*A[h]) * A[i]
                        u = u.stack(eik * projvk)
                    for vs in generate_cones_decomposition(u, h=0, w=ww, s=si,
                                                           tridiag=tridiag):
                        yield vs


def sum_angles(A, eps=1e-6, deg=100):
    D = list(generate_cones_decomposition(A))
    d = len(D)
    sum_angles = 0
    for j in range(d):
        if D[j][1] == 1:
            sum_angles += solid_angle_general(D[j][0], eps=eps, deg=deg,
                                              space="affine")
        else:
            sum_angles += -1*solid_angle_general(D[j][0], eps=eps, deg=deg,
                                                 space="affine")
    return sum_angles
